#!/usr/bin/env python3
"""
Direct sync from IntoTheCryptoverse RiskMetric data
No calculations - just copy their exact risk values
"""

import os
import sys
import json
from datetime import datetime
from supabase import create_client, Client
from pathlib import Path
import requests
from typing import List, Dict, Any

# Add project path
sys.path.append('/Users/dansidanutz/Desktop/ZmartBot/zmart-api')

class CryptoverseDirectSync:
    def __init__(self):
        # Supabase configuration
        self.supabase_url = "https://asjtxrmftmutcsnqgidy.supabase.co"
        self.supabase_key = os.getenv('SUPABASE_KEY') or self.get_supabase_key()

        if not self.supabase_key:
            print("‚ö†Ô∏è No Supabase key found - will save to local file instead")
            self.supabase = None
        else:
            self.supabase: Client = create_client(self.supabase_url, self.supabase_key)

        # Local storage path
        self.local_storage = Path("data/cryptoverse_riskmetric.json")

    def get_supabase_key(self):
        """Try to get Supabase key from various sources"""
        env_file = Path(".env")
        if env_file.exists():
            with open(env_file) as f:
                for line in f:
                    if line.startswith("SUPABASE_KEY="):
                        return line.split("=", 1)[1].strip()
        return None

    def save_cryptoverse_data(self, data: List[Dict[str, Any]]):
        """
        Save the scraped Cryptoverse data
        This is where you'll paste the data extracted from the website
        """

        # Example structure of what we expect from Cryptoverse
        # Each entry should have: symbol, price, risk_value, and optionally risk_band/zone

        sample_data = [
            {
                "symbol": "BTC",
                "price": 100000,
                "risk_value": 0.85,
                "risk_band": "0.8-0.9",
                "risk_zone": "Distribution",
                "signal": "SELL",
                "source": "intothecryptoverse",
                "timestamp": datetime.now().isoformat()
            },
            {
                "symbol": "ETH",
                "price": 4637,
                "risk_value": 0.777,
                "risk_band": "0.7-0.8",
                "risk_zone": "Distribution",
                "signal": "SELL",
                "source": "intothecryptoverse",
                "timestamp": datetime.now().isoformat()
            }
            # Add more data points here...
        ]

        # Save to local file
        self.local_storage.parent.mkdir(parents=True, exist_ok=True)
        with open(self.local_storage, 'w') as f:
            json.dump(data if data else sample_data, f, indent=2)

        print(f"‚úÖ Saved {len(data if data else sample_data)} data points to {self.local_storage}")

        # If Supabase is configured, sync to cloud
        if self.supabase and data:
            self.sync_to_supabase(data)

    def sync_to_supabase(self, data: List[Dict[str, Any]]):
        """Sync data to Supabase"""
        try:
            # Clear existing data (optional)
            symbols = list(set([d['symbol'] for d in data]))
            for symbol in symbols:
                self.supabase.table('cryptoverse_riskmetric').delete().eq('symbol', symbol).execute()

            # Insert new data in batches
            batch_size = 100
            for i in range(0, len(data), batch_size):
                batch = data[i:i+batch_size]
                self.supabase.table('cryptoverse_riskmetric').insert(batch).execute()

            print(f"‚úÖ Synced {len(data)} records to Supabase")

        except Exception as e:
            print(f"‚ùå Error syncing to Supabase: {e}")

    def create_table_sql(self):
        """SQL to create the Cryptoverse data table"""
        return """
        -- Table for IntoTheCryptoverse RiskMetric data
        CREATE TABLE IF NOT EXISTS public.cryptoverse_riskmetric (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            symbol TEXT NOT NULL,
            price DECIMAL NOT NULL,
            risk_value DECIMAL NOT NULL,
            risk_band TEXT,
            risk_zone TEXT,
            signal TEXT,
            source TEXT DEFAULT 'intothecryptoverse',
            timestamp TIMESTAMPTZ DEFAULT NOW(),
            created_at TIMESTAMPTZ DEFAULT NOW()
        );

        -- Indexes
        CREATE INDEX idx_cryptoverse_symbol ON public.cryptoverse_riskmetric(symbol);
        CREATE INDEX idx_cryptoverse_price ON public.cryptoverse_riskmetric(symbol, price);
        CREATE INDEX idx_cryptoverse_risk ON public.cryptoverse_riskmetric(symbol, risk_value);

        -- Enable RLS
        ALTER TABLE public.cryptoverse_riskmetric ENABLE ROW LEVEL SECURITY;
        CREATE POLICY "Enable read for all" ON public.cryptoverse_riskmetric FOR SELECT USING (true);

        -- Permissions
        GRANT SELECT ON public.cryptoverse_riskmetric TO anon;
        GRANT ALL ON public.cryptoverse_riskmetric TO authenticated;
        """

    def load_from_browser_export(self, json_file: str):
        """
        Load data exported from browser
        After scraping IntoTheCryptoverse, export the data as JSON and load it here
        """
        try:
            with open(json_file, 'r') as f:
                file_content = json.load(f)

            # Check if data is wrapped in a 'data' key
            if isinstance(file_content, dict) and 'data' in file_content:
                data = file_content['data']
            else:
                data = file_content if isinstance(file_content, list) else [file_content]

            print(f"üìä Loaded {len(data)} records from {json_file}")

            # Process and save
            self.save_cryptoverse_data(data)

            return data

        except Exception as e:
            print(f"‚ùå Error loading browser export: {e}")
            return None

    def get_current_risk(self, symbol: str, price: float = None):
        """Get current risk value for a symbol"""

        # First try Supabase
        if self.supabase:
            try:
                if price:
                    # Get closest price point
                    result = self.supabase.table('cryptoverse_riskmetric')\
                        .select('*')\
                        .eq('symbol', symbol)\
                        .order('price')\
                        .execute()

                    if result.data:
                        # Find closest price
                        closest = min(result.data, key=lambda x: abs(x['price'] - price))
                        return closest
                else:
                    # Get latest entry
                    result = self.supabase.table('cryptoverse_riskmetric')\
                        .select('*')\
                        .eq('symbol', symbol)\
                        .order('timestamp', desc=True)\
                        .limit(1)\
                        .execute()

                    if result.data:
                        return result.data[0]

            except Exception as e:
                print(f"‚ö†Ô∏è Supabase error: {e}")

        # Fall back to local file
        if self.local_storage.exists():
            with open(self.local_storage, 'r') as f:
                data = json.load(f)

            symbol_data = [d for d in data if d['symbol'] == symbol]
            if symbol_data:
                if price:
                    # Find closest price
                    return min(symbol_data, key=lambda x: abs(x.get('price', 0) - price))
                else:
                    # Return first/latest
                    return symbol_data[0]

        return None

    def run(self):
        """Main execution"""
        print("=" * 60)
        print("üåê INTOTHECRYPTOVERSE DIRECT SYNC")
        print("=" * 60)
        print("This tool syncs RiskMetric data directly from IntoTheCryptoverse")
        print("No calculations - just their exact values")
        print("=" * 60)

        # Save SQL for table creation
        sql_file = Path("supabase/migrations/20250914_cryptoverse_direct_table.sql")
        sql_file.parent.mkdir(parents=True, exist_ok=True)
        sql_file.write_text(self.create_table_sql())
        print(f"üìù SQL saved to: {sql_file}")

        print("\nüìã INSTRUCTIONS:")
        print("1. Open browser and navigate to https://app.intothecryptoverse.com/crypto")
        print("2. Use Browser MCP or DevTools to extract the risk data")
        print("3. Save as JSON file")
        print("4. Run: python3 sync_intothecryptoverse_direct.py --load exported_data.json")

        print("\nüîç Example data structure needed:")
        print(json.dumps({
            "symbol": "BTC",
            "price": 100000,
            "risk_value": 0.85,
            "risk_band": "0.8-0.9",
            "risk_zone": "Distribution"
        }, indent=2))

        # Check for command line arguments
        if len(sys.argv) > 2 and sys.argv[1] == '--load':
            json_file = sys.argv[2]
            self.load_from_browser_export(json_file)
        else:
            # Save sample data for now
            self.save_cryptoverse_data([])

            # Test retrieval
            print("\nüîç Testing data retrieval...")
            eth_risk = self.get_current_risk('ETH', 4637)
            if eth_risk:
                print(f"ETH at $4,637: Risk = {eth_risk.get('risk_value', 'N/A')}")

if __name__ == "__main__":
    syncer = CryptoverseDirectSync()
    syncer.run()