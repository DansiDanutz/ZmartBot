"""
MDC/MDS Document Processor
==========================
Handles parsing, validation, generation, and enhancement of MDC/MDS documents
"""

import re
import json
import yaml
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
import hashlib
from jinja2 import Template, Environment, FileSystemLoader
import structlog

logger = structlog.get_logger()

class DocumentType(Enum):
    """Document types supported"""
    MDC = "mdc"  # Markdown Component
    MDS = "mds"  # Markdown Service
    MDX = "mdx"  # Markdown Extension (future)

@dataclass
class ParsedDocument:
    """Represents a parsed MDC/MDS document"""
    doc_type: DocumentType
    datasource: Optional[str] = None
    title: str = ""
    version: str = "1.0.0"
    content: str = ""
    functions: List[Dict[str, Any]] = field(default_factory=list)
    steps: List[Dict[str, Any]] = field(default_factory=list)
    variables: Dict[str, str] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    sections: Dict[str, str] = field(default_factory=dict)
    connections: List[Dict[str, Any]] = field(default_factory=list)
    hash: str = ""
    
    def __post_init__(self):
        """Calculate document hash"""
        if not self.hash:
            content_hash = hashlib.sha256(self.content.encode()).hexdigest()
            self.hash = content_hash[:16]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        result = asdict(self)
        # Convert enum to its value
        if isinstance(result['doc_type'], DocumentType):
            result['doc_type'] = result['doc_type'].value
        return result
    
    def to_json(self) -> str:
        """Convert to JSON string"""
        return json.dumps(self.to_dict(), indent=2, default=str)

class MDCMDSProcessor:
    """
    Advanced MDC/MDS document processor with GPT integration
    """
    
    def __init__(self, gpt_foundation, template_dir: str = "templates"):
        self.gpt = gpt_foundation
        self.template_dir = Path(template_dir)
        self.env = Environment(loader=FileSystemLoader(template_dir))
        self._load_templates()
        self.processing_stats = {
            "documents_processed": 0,
            "documents_generated": 0,
            "documents_enhanced": 0,
            "validation_errors": 0
        }
        
    def _load_templates(self):
        """Load processing templates"""
        self.templates = {
            "mdc_base": self._load_template("mdc_base.jinja2"),
            "mds_service": self._load_template("mds_service.jinja2"),
            "function_block": self._load_template("function_block.jinja2"),
            "step_block": self._load_template("step_block.jinja2")
        }
        
        # Inline templates if files don't exist
        if not self.templates["mdc_base"]:
            self.templates["mdc_base"] = Template("""
# {{ title }}
{% if datasource %}@datasource: {{ datasource }}{% endif %}
> Version: {{ version }} | Type: {{ doc_type }} | Generated: {{ timestamp }}

## Overview
{{ description }}

{% for function in functions %}
## @function: {{ function.name }}
{{ function.description }}

### Implementation
```{{ function.language | default('python') }}
{{ function.code }}
```

### Parameters
{% for param in function.parameters %}
- `{{ param.name }}` ({{ param.type }}): {{ param.description }}
{% endfor %}

### Returns
- {{ function.returns }}
{% endfor %}

{% for step in steps %}
## @step: {{ step.name }}
{{ step.description }}

### Process
{% for action in step.actions %}
{{ loop.index }}. {{ action }}
{% endfor %}

### Validation
- {{ step.validation }}
{% endfor %}

## Variables
{% for var_name, var_value in variables.items() %}
- `{{ var_name }}`: {{ var_value }}
{% endfor %}

## Connections
{% for conn in connections %}
- **{{ conn.name }}** ({{ conn.type }}): {{ conn.description }}
{% endfor %}

---
*Generated by GptMDSagentService v{{ service_version }}*
""")
    
    def _load_template(self, name: str) -> Optional[Template]:
        """Load a single template file"""
        template_path = self.template_dir / name
        if template_path.exists():
            return Template(template_path.read_text())
        return None
    
    def parse_document(self, content: str, doc_type: DocumentType = DocumentType.MDC) -> ParsedDocument:
        """
        Parse MDC/MDS content into structured document
        
        Args:
            content: Raw document content
            doc_type: Type of document
            
        Returns:
            ParsedDocument object
        """
        doc = ParsedDocument(doc_type=doc_type, content=content)
        
        # Parse datasource
        datasource_match = re.search(r'@datasource:\s*(.+)', content, re.IGNORECASE)
        if datasource_match:
            doc.datasource = datasource_match.group(1).strip()
        
        # Parse title (first # heading)
        title_match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
        if title_match:
            doc.title = title_match.group(1).strip()
        
        # Parse version
        version_match = re.search(r'[Vv]ersion:\s*([0-9.]+)', content)
        if version_match:
            doc.version = version_match.group(1)
        
        # Parse functions with enhanced extraction
        function_pattern = r'##?\s*@function:\s*(\w+)(.*?)(?=##?\s*@|##?\s*Step:|$)'
        functions = re.findall(function_pattern, content, re.DOTALL | re.IGNORECASE)
        
        for func_name, func_content in functions:
            function_data = self._parse_function(func_name, func_content)
            doc.functions.append(function_data)
        
        # Parse steps with enhanced extraction
        step_pattern = r'##?\s*@step:\s*(\w+)(.*?)(?=##?\s*@|##?\s*Function:|$)'
        steps = re.findall(step_pattern, content, re.DOTALL | re.IGNORECASE)
        
        for step_name, step_content in steps:
            step_data = self._parse_step(step_name, step_content)
            doc.steps.append(step_data)
        
        # Parse variables ({{VAR_NAME}} pattern)
        variable_pattern = r'\{\{(\w+)\}\}'
        variables = re.findall(variable_pattern, content)
        for var in set(variables):
            # Extract variable value if defined
            var_def_pattern = rf'{var}\s*=\s*["\']?([^"\'\n]+)'
            var_match = re.search(var_def_pattern, content)
            if var_match:
                doc.variables[var] = var_match.group(1)
            else:
                doc.variables[var] = f"undefined_{var.lower()}"
        
        # Parse connections
        connection_pattern = r'(?:connection|integration|dependency):\s*([^\n]+)'
        connections = re.findall(connection_pattern, content, re.IGNORECASE)
        for conn in connections:
            doc.connections.append({
                "name": conn.strip(),
                "type": "dependency",
                "description": f"Connection to {conn.strip()}"
            })
        
        # Extract major sections
        sections = self._extract_sections(content)
        doc.sections = sections
        
        # Update metadata
        doc.metadata = {
            "parsed_at": datetime.now().isoformat(),
            "line_count": len(content.split('\n')),
            "word_count": len(content.split()),
            "has_code": '```' in content,
            "has_tables": '|' in content and '---' in content
        }
        
        self.processing_stats["documents_processed"] += 1
        logger.info("Document parsed",
                   type=doc_type.value,
                   title=doc.title,
                   functions=len(doc.functions),
                   steps=len(doc.steps))
        
        return doc
    
    def _parse_function(self, name: str, content: str) -> Dict[str, Any]:
        """Parse a function block"""
        function = {
            "name": name,
            "description": "",
            "parameters": [],
            "returns": "None",
            "code": "",
            "language": "python",
            "examples": []
        }
        
        # Extract description (first paragraph)
        desc_match = re.search(r'^([^#\n]+)', content.strip())
        if desc_match:
            function["description"] = desc_match.group(1).strip()
        
        # Extract code block
        code_match = re.search(r'```(\w+)?\n(.*?)```', content, re.DOTALL)
        if code_match:
            function["language"] = code_match.group(1) or "python"
            function["code"] = code_match.group(2).strip()
        
        # Extract parameters
        param_pattern = r'(?:param|parameter|arg|argument)\s+(\w+):\s*([^\n]+)'
        params = re.findall(param_pattern, content, re.IGNORECASE)
        for param_name, param_desc in params:
            function["parameters"].append({
                "name": param_name,
                "type": "Any",  # Would need type inference
                "description": param_desc.strip()
            })
        
        # Extract return value
        return_match = re.search(r'(?:return|returns):\s*([^\n]+)', content, re.IGNORECASE)
        if return_match:
            function["returns"] = return_match.group(1).strip()
        
        return function
    
    def _parse_step(self, name: str, content: str) -> Dict[str, Any]:
        """Parse a step block"""
        step = {
            "name": name,
            "description": "",
            "actions": [],
            "validation": "",
            "prerequisites": [],
            "outputs": []
        }
        
        # Extract description
        desc_match = re.search(r'^([^#\n-]+)', content.strip())
        if desc_match:
            step["description"] = desc_match.group(1).strip()
        
        # Extract numbered or bulleted actions
        action_pattern = r'(?:^|\n)\s*(?:\d+\.|-|\*)\s+(.+?)(?=\n\s*(?:\d+\.|-|\*)|$)'
        actions = re.findall(action_pattern, content, re.MULTILINE)
        step["actions"] = [action.strip() for action in actions]
        
        # Extract validation
        validation_match = re.search(r'(?:validation|verify|check):\s*([^\n]+)', 
                                    content, re.IGNORECASE)
        if validation_match:
            step["validation"] = validation_match.group(1).strip()
        
        # Extract prerequisites
        prereq_match = re.search(r'(?:prerequisite|requires|needs):\s*([^\n]+)', 
                               content, re.IGNORECASE)
        if prereq_match:
            step["prerequisites"] = [p.strip() for p in prereq_match.group(1).split(',')]
        
        return step
    
    def _extract_sections(self, content: str) -> Dict[str, str]:
        """Extract major sections from document"""
        sections = {}
        
        # Find all ## headings
        section_pattern = r'^##\s+([^@\n]+)\n(.*?)(?=^##\s+|\Z)'
        matches = re.findall(section_pattern, content, re.MULTILINE | re.DOTALL)
        
        for heading, section_content in matches:
            # Skip function and step sections
            if not heading.strip().startswith('@'):
                sections[heading.strip()] = section_content.strip()
        
        return sections
    
    async def generate_document(self,
                               description: str,
                               doc_type: DocumentType = DocumentType.MDC,
                               service_type: str = "backend",
                               include_examples: bool = True) -> str:
        """
        Generate new MDC/MDS document from description
        
        Args:
            description: Service/component description
            doc_type: Type of document to generate
            service_type: Type of service (backend, frontend, etc.)
            include_examples: Whether to include code examples
            
        Returns:
            Generated MDC/MDS content
        """
        # Build comprehensive prompt
        prompt = f"""
        Create a complete {doc_type.value.upper()} document for the following:
        
        Description: {description}
        Service Type: {service_type}
        
        Requirements:
        1. Include @datasource declaration if applicable
        2. Clear title with # heading
        3. Comprehensive overview section
        4. At least 3 @function definitions with:
           - Clear descriptions
           - Parameter documentation
           - Return value documentation
           - Implementation code in Python
        5. At least 3 @step procedures with:
           - Clear descriptions
           - Numbered actions
           - Validation criteria
        6. Variables section with {{{{VARIABLE_NAME}}}} format
        7. Dependencies and integrations section
        8. Error handling section
        9. Monitoring and metrics section
        10. Deployment configuration
        
        {"Include practical code examples for each function." if include_examples else ""}
        
        Format: Strict {doc_type.value.upper()} format with proper markdown.
        Style: Technical, precise, production-ready.
        """
        
        system_message = f"""You are an expert {doc_type.value.upper()} document generator 
        for the ZmartBot ecosystem. Create comprehensive, production-ready documentation 
        that follows best practices and includes all necessary technical details."""
        
        # Generate with GPT
        response = await self.gpt.call_gpt(prompt, system_message)
        generated_content = response.content
        
        # Validate generated document
        try:
            parsed = self.parse_document(generated_content, doc_type)
            if not parsed.title or not parsed.functions:
                logger.warning("Generated document missing required elements")
                # Attempt to enhance
                generated_content = await self.enhance_document(
                    generated_content,
                    "Add missing title and functions"
                )
        except Exception as e:
            logger.error(f"Validation failed for generated document: {e}")
        
        self.processing_stats["documents_generated"] += 1
        logger.info("Document generated",
                   type=doc_type.value,
                   length=len(generated_content))
        
        return generated_content
    
    async def enhance_document(self,
                              content: str,
                              instructions: str = "",
                              preserve_original: bool = True) -> str:
        """
        Enhance existing MDC/MDS document
        
        Args:
            content: Original document content
            instructions: Specific enhancement instructions
            preserve_original: Whether to preserve all original content
            
        Returns:
            Enhanced document content
        """
        # Parse original document
        doc = self.parse_document(content)
        
        prompt = f"""
        Enhance this {doc.doc_type.value.upper()} document:
        
        Current Structure:
        - Title: {doc.title}
        - Functions: {[f['name'] for f in doc.functions]}
        - Steps: {[s['name'] for s in doc.steps]}
        - Variables: {list(doc.variables.keys())}
        
        Document Content:
        {content[:3000]}... (truncated if needed)
        
        Enhancement Instructions: {instructions or 'Improve clarity, completeness, and technical accuracy'}
        
        Requirements:
        {"- Preserve ALL original content, only add improvements" if preserve_original else ""}
        - Add missing sections (error handling, monitoring, deployment)
        - Improve function documentation
        - Add code examples where missing
        - Enhance step procedures with validation
        - Add connection/integration details
        - Include best practices and warnings
        - Add troubleshooting section
        """
        
        system_message = """You are an expert technical documentation specialist.
        Enhance MDC/MDS documents while maintaining their structure and format.
        Focus on clarity, completeness, and production readiness."""
        
        response = await self.gpt.call_gpt(prompt, system_message)
        enhanced_content = response.content
        
        self.processing_stats["documents_enhanced"] += 1
        logger.info("Document enhanced",
                   original_length=len(content),
                   enhanced_length=len(enhanced_content))
        
        return enhanced_content
    
    async def validate_document(self, content: str) -> Dict[str, Any]:
        """
        Validate MDC/MDS document structure and content
        
        Args:
            content: Document content to validate
            
        Returns:
            Validation results with issues and suggestions
        """
        validation_results = {
            "valid": True,
            "errors": [],
            "warnings": [],
            "suggestions": [],
            "score": 100
        }
        
        try:
            doc = self.parse_document(content)
            
            # Required elements validation
            if not doc.title:
                validation_results["errors"].append("Missing document title")
                validation_results["score"] -= 20
            
            if not doc.functions and not doc.steps:
                validation_results["errors"].append("No functions or steps defined")
                validation_results["score"] -= 30
            
            # Quality checks
            if len(doc.functions) < 2:
                validation_results["warnings"].append(
                    f"Only {len(doc.functions)} function(s) defined, recommend at least 2"
                )
                validation_results["score"] -= 10
            
            # Check for documentation completeness
            for func in doc.functions:
                if not func.get("description"):
                    validation_results["warnings"].append(
                        f"Function '{func['name']}' missing description"
                    )
                    validation_results["score"] -= 5
                
                if not func.get("parameters"):
                    validation_results["suggestions"].append(
                        f"Consider documenting parameters for '{func['name']}'"
                    )
            
            # Check for code examples
            if not doc.metadata.get("has_code"):
                validation_results["suggestions"].append(
                    "Consider adding code examples"
                )
            
            # Set validity
            validation_results["valid"] = len(validation_results["errors"]) == 0
            validation_results["score"] = max(0, validation_results["score"])
            
        except Exception as e:
            validation_results["valid"] = False
            validation_results["errors"].append(f"Parse error: {str(e)}")
            validation_results["score"] = 0
            self.processing_stats["validation_errors"] += 1
        
        logger.info("Document validated",
                   valid=validation_results["valid"],
                   score=validation_results["score"],
                   errors=len(validation_results["errors"]))
        
        return validation_results
    
    def render_document(self, doc: ParsedDocument, template_name: str = "mdc_base") -> str:
        """
        Render document using template
        
        Args:
            doc: Parsed document
            template_name: Template to use
            
        Returns:
            Rendered document content
        """
        template = self.templates.get(template_name)
        if not template:
            logger.error(f"Template '{template_name}' not found")
            return doc.content
        
        render_context = {
            **doc.to_dict(),
            "timestamp": datetime.now().isoformat(),
            "service_version": "1.0.0"
        }
        
        return template.render(**render_context)
    
    def get_stats(self) -> Dict[str, int]:
        """Get processing statistics"""
        return self.processing_stats.copy()
