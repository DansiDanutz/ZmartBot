
## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

## 🤖 MCP (Model Context Protocol) Integration

### **MCP Server Pairing**
**Status**: ✅ **ACTIVE** - OrchestrationStart MCP Integration
**MCP Servers**: `claude-code`, `byterover`, `ui-tars`, `figma`, `supabase`
**Configuration**: `/Users/dansidanutz/.cursor/mcp.json`
**Integration Type**: Multi-MCP Service Integration

### **MCP Integration Features**
- **Claude Code Integration**: AI-powered orchestration startup and optimization
- **Memory Gateway**: Persistent orchestration state and startup metadata
- **UI Automation**: Automated orchestration monitoring and health checks
- **Figma Integration**: Orchestration dashboard design and UI management
- **Supabase Integration**: Cloud-based orchestration analytics and reporting

### **MCP Pairing Benefits**
- **Enhanced Orchestration**: AI-powered orchestration startup and optimization
- **Persistent State**: Memory persistence for orchestration workflows and startup state
- **Automated Monitoring**: Automated orchestration health monitoring and management
- **Design Integration**: Seamless integration with UI design workflows
- **Cloud Analytics**: Advanced orchestration analytics and reporting monitoring

### **MCP Usage Examples**
```bash
# Test OrchestrationStart MCP connection
curl -X GET http://127.0.0.1:8000/health

# Execute orchestration startup via MCP
curl -X POST http://127.0.0.1:8000/orchestration/start \
  -H "Content-Type: application/json" \
  -d '{"action": "start_services", "services": ["frontend", "backend"]}'
```

### **MCP Integration Status**
- **Connection**: ✅ Active and responsive
- **Health Check**: ✅ All MCP servers healthy
- **Memory Sync**: ✅ Real-time memory synchronization
- **UI Automation**: ✅ Automated monitoring active
- **Cloud Sync**: ✅ Supabase integration active

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 33 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ✅
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ✅
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ✅
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ✅
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ✅

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ✅
7. **`zmart_api`** (Port 8000) - Core API ✅
8. **`port-manager-service`** (Port 8050) - Port Management ✅
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ✅
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ✅

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ✅
12. **`service-dashboard`** (Port 3000) - Service Dashboard ✅

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ✅
14. **`zmart_backtesting`** (Port 8013) - Backtesting ✅
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ✅
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ✅
17. **`zmart_risk_management`** (Port 8010) - Risk Management ✅

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ✅
19. **`zmart_websocket`** (Port 8009) - WebSocket ✅
20. **`zmart_alert_system`** (Port 8012) - Alert System ✅

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ✅
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ✅
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ✅

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ✅
25. **`kucoin`** (Port 8302) - KuCoin Worker ✅
26. **`binance`** (Port 8303) - Binance Worker ✅

#### **Orchestration & Discovery Services** (Startup Priority 27-32)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ✅
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ✅
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ✅ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ✅ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ✅ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**
32. **`enhanced-mdc-monitor`** (Port NULL) - Enhanced MDC Monitor ✅ **PASSPORT: ZMBT-SYSTEM-20250830-ENHANCED**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 6 services (Discovery, master orchestration, MDC dashboard, certification, achievements, enhanced MDC monitor)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ✅ **Previously Missing**: 28 services added
- ✅ **Previously Included**: 17 services (with naming corrections)
- ✅ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ✅ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"✅ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"⚠️ {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"⚠️ {service_name} started but health check failed: {e}")
            else:
                logger.info(f"✅ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"❌ Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\n🎯 ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ⇄ Port ⇄ PID ⇄ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("📸 Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("📸→🔴 TRANSITION: Cached data → Live data")
        log_info("🔄 System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("✅ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"🔍 Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"✅ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"🎯 Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ✅ Frontend Dashboard responding on port 3400
- ✅ Backend API responding on port 8000
- ✅ All dynamic services have valid ports
- ✅ No port conflicts detected

### Database Synchronization
- ✅ All services registered in database
- ✅ Port assignments are current
- ✅ No orphaned entries
- ✅ Backup created successfully

### Orchestration Status
- ✅ All services coordinated
- ✅ Port Manager database updated
- ✅ Configuration files synchronized
- ✅ BackendDoctorAgent monitoring active
- ✅ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ✅ **Unique port assignment**
- ✅ **Database connectivity**
- ✅ **Valid service passport**
- ✅ **Complete MDC documentation**
- ✅ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**
