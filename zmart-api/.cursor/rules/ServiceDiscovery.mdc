
## Description
Core service component of the ZmartBot ecosystem providing essential functionality.

@agent: ServiceDiscoveryAgent

## ü§ñ MCP (Model Context Protocol) Integration

### **MCP Server Pairing**
**Status**: ‚úÖ **ACTIVE** - Service Discovery MCP Integration
**MCP Servers**: `claude-code`, `byterover`, `ui-tars`, `figma`, `supabase`
**Configuration**: `/Users/dansidanutz/.cursor/mcp.json`
**Integration Type**: Multi-MCP Service Integration

### **MCP Integration Features**
- **Claude Code Integration**: AI-powered service discovery and analysis
- **Memory Gateway**: Persistent service registry and discovery metadata
- **UI Automation**: Automated service monitoring and health checks
- **Figma Integration**: Service discovery dashboard design and UI management
- **Supabase Integration**: Cloud-based service registry and analytics

### **MCP Pairing Benefits**
- **Enhanced Discovery**: AI-powered service detection and analysis
- **Persistent Registry**: Memory persistence for service discovery workflows
- **Automated Monitoring**: Automated service health monitoring and discovery
- **Design Integration**: Seamless integration with UI design workflows
- **Cloud Analytics**: Advanced service analytics and discovery monitoring

### **MCP Usage Examples**
```bash
# Test Service Discovery MCP connection
curl -X GET http://127.0.0.1:8550/health

# Execute discovery task via MCP
curl -X POST http://127.0.0.1:8550/discovery/scan \
  -H "Content-Type: application/json" \
  -d '{"action": "scan_services", "path": "/Users/dansidanutz/Desktop/ZmartBot/"}'
```

### **MCP Integration Status**
- **Connection**: ‚úÖ Active and responsive
- **Health Check**: ‚úÖ All MCP servers healthy
- **Memory Sync**: ‚úÖ Real-time memory synchronization
- **UI Automation**: ‚úÖ Automated monitoring active
- **Cloud Sync**: ‚úÖ Supabase integration active

# Service Discovery & Port Assignment System

## üéØ **REGISTRATION STATUS: COMPLETE**
- **Passport ID**: `ZMBT-ORC-20250827-AD7F65`
- **Service Registry**: ‚úÖ **REGISTERED** (Status: ACTIVE)
- **Passport Registry**: ‚úÖ **REGISTERED** (Status: ACTIVE)
- **Port Assignment**: ‚úÖ **8550** (Orchestration Services Range)
- **Master Orchestration**: ‚úÖ **INTEGRATED** (Service #31)
- **OrchestrationStart**: ‚úÖ **INCLUDED** (Service #32 in startup order)
- **Health Status**: ‚úÖ **HEALTHY** (Running on port 8550)
- **Registration Date**: 2025-08-27T16:44:04Z

## Overview
The **Service Discovery & Port Assignment System** automatically detects new services added to the orchestration, assigns unique ports, and ensures the Master Orchestration Agent recognizes and manages them. This system provides seamless integration of new services without manual configuration.

## üö® **DISCOVERY DATABASE WORKFLOW** (AUTOMATED SYSTEM)

### **üîç 3-DATABASE SERVICE LIFECYCLE INTEGRATION**

#### **Discovery Database Automation** (Level 1):
- **Purpose**: Scan entire ZmartBot folder for Python services with MDC files
- **Workflow Steps**:
  1. **FOLDER SCANNING**: Scan `/Users/dansidanutz/Desktop/ZmartBot/` for all `.py` files
  2. **MDC VERIFICATION**: Check if each `.py` file has corresponding `.mdc` file
  3. **DATABASE ADDITION**: IF `.py` + `.mdc` exists AND not already in database ‚Üí ADD to `discovery_registry.db`
  4. **DATABASE EXCLUSION**: IF `.py` has NO `.mdc` file ‚Üí DO NOT ADD (information only)
  5. **HOURLY AUTOMATION**: Update discovery database every 60 minutes automatically
- **Database Location**: `discovery_registry.db` (Level 1 of 3-database architecture)
- **Current Count**: Services with both `.py` and `.mdc` files tracked for future implementation

#### **Discovery Database Rules** (MANDATORY):
- **Rule 1**: ONLY `.py` files WITH corresponding `.mdc` files are added to discovery database
- **Rule 2**: `.py` files WITHOUT `.mdc` files are NOT added to database (information only)
- **Rule 3**: Discovery database is updated automatically every hour (3600 seconds)
- **Rule 4**: Discovery database tracks Level 1 services (pre-passport stage)
- **Rule 5**: Discovery database prevents duplicate entries (unique service names)
- **Rule 6**: Discovery services are tracked for future passport assignment

#### **3-Database Service Lifecycle Flow**:
```
üîç LEVEL 1: DISCOVERY DATABASE
‚îú‚îÄ‚îÄ Scan ZmartBot folder for .py files
‚îú‚îÄ‚îÄ Verify corresponding .mdc file exists
‚îú‚îÄ‚îÄ Add to discovery_registry.db if both exist
‚îî‚îÄ‚îÄ Hourly automated updates

üé´ LEVEL 2: PASSPORT DATABASE  
‚îú‚îÄ‚îÄ System interaction begins
‚îú‚îÄ‚îÄ Port assignment triggers passport
‚îú‚îÄ‚îÄ Add to passport_registry.db
‚îî‚îÄ‚îÄ Service becomes active

üèÜ LEVEL 3: REGISTRATION DATABASE
‚îú‚îÄ‚îÄ Complete registration workflow  
‚îú‚îÄ‚îÄ All certification requirements met
‚îú‚îÄ‚îÄ Add to service_registry.db
‚îî‚îÄ‚îÄ Service becomes CERTIFIED
```

### **ServiceDiscovery Integration with Discovery Database**:
- **Discovery Detection**: ServiceDiscovery monitors discovery_registry.db for new entries
- **Promotion Trigger**: When discovery service needs system integration ‚Üí Level 2 promotion
- **Port Assignment**: ServiceDiscovery assigns ports to services promoted from discovery level
- **Passport Trigger**: Port assignment triggers passport assignment workflow
- **Complete Tracking**: Full service lifecycle visibility from discovery to certification

## üèóÔ∏è CRITICAL ARCHITECTURE DISCOVERY

### Service Maturity Classification System
**Major Discovery**: Service Discovery revealed ZmartBot implements a two-tier service architecture with distinct maturity levels:

#### Current System Metrics (August 2025)
- **Total Active Services**: 42 (all running/discovered services)
- **Registered Services**: 29 (production-ready with Passport IDs)
- **Development Services**: 13 (active but in development phase)
- **Connection Network**: 1,388 total connections (533 active + 835 potential + 20 priority)
- **Documentation Coverage**: 206 MDC files
- **üèÜ Winners Database**: 13+ tracked winners with full lifecycle management
- **ü§ñ AI Analysis**: 15-minute automated cycles with ChatGPT integration
- **üìä 30-Day Selection**: Proven winner selection algorithm operational

#### Service Classification Tiers

##### üõÇ Tier 1: Registered Services (29)
- **Status**: Production-ready with Passport registration
- **Quality Gate**: Passed testing and validation
- **Characteristics**: Stable, monitored, maintained
- **Examples**: Services with valid passport_id fields

##### üîß Tier 2: Development Services (13)
- **Status**: Active but without Passport registration  
- **Quality Gate**: Still in development/testing phase
- **Characteristics**: Iterative development, subject to changes
- **Pipeline**: Working toward Passport registration

#### Dashboard Implementation Insight
**Critical Fix Applied**: Service Discovery dashboard was incorrectly displaying 206 (MDC files) as "Active Services"
**Resolution**: Implemented proper distinction between:
1. **MDC Documentation**: 206 files (documentation layer)
2. **Active Services**: 42 (runtime layer) 
3. **Registered Services**: 29 (production layer)

### üöÄ AUTOMATED RECOMMENDATION SYSTEM (August 2025)

#### Major Implementation: AI-Powered Integration Analysis
**Breakthrough Achievement**: Implemented comprehensive automated recommendation system with ChatGPT integration and Winners Database tracking.

##### Core Components Implemented:

###### 1. **15-Minute Analysis Cycles**
- **Automated Pair Selection**: Random MDC file pairs analyzed every 15 minutes
- **ChatGPT Integration**: GPT-4 powered compatibility analysis
- **Duplicate Prevention**: 4-hour cooldown prevents re-analysis of same pairs
- **Compatibility Scoring**: 0-100 scale with detailed analysis
- **Database Storage**: All analyses stored with full metadata

###### 2. **4-Hour Winner Selection**
- **Automatic Winner Detection**: Highest-scoring pair selected every 4 hours
- **Winner Generation**: 6 winners per day (24h √∑ 4h cycles)
- **MDC File Creation**: Comprehensive integration files generated
- **Winners Database**: Complete lifecycle tracking implemented

###### 3. **Winners Database System**
- **Comprehensive Tracking**: Full winner lifecycle (PENDING ‚Üí COMPLETED ‚Üí Performance)
- **13+ Winners Tracked**: Live system with real performance data
- **Average Compatibility**: 87.38/100 across all winners
- **Performance Metrics**: Latency, uptime, error rates, throughput tracking
- **Implementation Phases**: 6-phase deployment tracking

###### 4. **30-Day Winner Selection Algorithm**
- **Proven Performance Focus**: Selects from COMPLETED winners only
- **Best Performer Selection**: Highest compatibility score from last 30 days
- **Recommendation Generation**: Creates high-priority recommendations
- **Success Example**: `AlertSystem ‚Üî NotificationService` (98/100 score)

##### Technical Architecture:

###### Database Schema:
```sql
-- Winners tracking with full lifecycle
CREATE TABLE winners (
    winner_id TEXT UNIQUE,
    service_a TEXT, service_b TEXT,
    compatibility_score REAL,
    status TEXT DEFAULT 'PENDING',
    selected_at TIMESTAMP,
    implemented_at TIMESTAMP,
    performance_metrics TEXT
);

-- Analysis storage
CREATE TABLE mdc_pair_analyses (
    service_a TEXT, service_b TEXT,
    analysis_content TEXT,
    score REAL,
    analyzed_at TIMESTAMP,
    is_winner BOOLEAN
);
```

###### API Endpoints:
- **`/api/analyzer-pairs`**: View all 15-minute analysis results
- **`/api/analyzer-winners`**: Access Winners Database
- **`/api/winners-30-day-selection`**: Trigger 30-day winner selection
- **`/api/combinations-stats`**: Live analysis statistics

##### Performance Metrics:
- **Total Analyses**: 10+ pairs analyzed and stored
- **Winner Success Rate**: 87.38/100 average compatibility
- **30-Day Selection**: Successfully identified best performer (98/100)
- **Database Operations**: Real-time storage and retrieval
- **ChatGPT Integration**: Successful API calls with structured analysis

##### Operational Status:
- **Service Discovery Dashboard**: http://localhost:8550 (OPERATIONAL)
- **Automated Cycles**: 15-minute analysis + 4-hour winner selection (ACTIVE)
- **Winners Database**: Comprehensive tracking system (OPERATIONAL)
- **30-Day Algorithm**: Proven winner selection (TESTED & WORKING)

##### Dashboard Interface Features:

###### 1. **Database Tracking Cards**
- **Generated Pairs & Results Card**: Real-time display of all analyzed pairs
- **Winners Database Card**: Comprehensive winner tracking with status
- **Service Combinations Database**: Live 15-minute generated combinations
- **Statistics Display**: Total analyses, average scores, recent activity

###### 2. **Interactive Features**
- **"Add Another Recommendation"**: Manual trigger for top 3 database recommendations  
- **Expandable Content**: Landscape preview cards for detailed MDC analysis
- **Status Indicators**: PENDING ‚Üí COMPLETED ‚Üí Performance tracking
- **Real-time Updates**: 30-second refresh cycle for live data

###### 3. **MDC Generation Workflow**
- **Preview Integration**: Combined MDC file preview before generation
- **ChatGPT Enhancement**: AI-powered comprehensive analysis option
- **File Organization**: Automatic sorting with "integration-" prefix
- **Completion Tracking**: Prevents duplicate generation

##### Success Metrics Achieved:
- **‚úÖ 15-Minute Cycles**: Continuous automated analysis operational
- **‚úÖ 4-Hour Winners**: 6 winners per day generation confirmed  
- **‚úÖ 30-Day Selection**: Best performer algorithm tested successfully
- **‚úÖ Database Integration**: Complete lifecycle tracking implemented
- **‚úÖ ChatGPT Integration**: AI-powered analysis working with fallback
- **‚úÖ Dashboard Interface**: Full user interaction system operational
- **‚úÖ API Ecosystem**: All endpoints tested and functional

##### Implementation Files Created:
```
zmart-api/dashboard/MDC-Dashboard/service-discovery/
‚îú‚îÄ‚îÄ service_discovery_server.py         # Main Flask server with all APIs
‚îú‚îÄ‚îÄ recommendation_analyzer.py          # 15-min cycles + 4-hr winner selection
‚îú‚îÄ‚îÄ winners_database.py                 # Comprehensive Winners Database system
‚îú‚îÄ‚îÄ index.html                          # Service Discovery Dashboard interface
‚îú‚îÄ‚îÄ config.json                         # OpenAI API key configuration
‚îú‚îÄ‚îÄ recommendations.db                  # Analysis results database  
‚îú‚îÄ‚îÄ winners.db                          # Winners lifecycle database
‚îú‚îÄ‚îÄ test_6_simulations_winner.py        # Winner selection testing
‚îú‚îÄ‚îÄ test_winners_database_30day.py      # 30-day algorithm testing
‚îî‚îÄ‚îÄ .cursor/rules/integration/winners/  # Generated winner MDC files
    ‚îú‚îÄ‚îÄ integration-AlertSystem-NotificationService.mdc
    ‚îú‚îÄ‚îÄ integration-test_MachineLearningServer-test_snapshot_service_server.mdc
    ‚îî‚îÄ‚îÄ [additional winner files...]
```

### üìÇ **DISCOVERY FOLDER ORGANIZATION (August 2025)**

#### Auto-Discovered MDC Files Management System
**Major Achievement**: Complete organization of 116 auto-discovered MDC files into categorized Discovery folder structure for enhanced tracking and system visibility.

##### Discovery Folder Structure:
```
.cursor/rules/discovery/
‚îú‚îÄ‚îÄ README.md                           # Main discovery folder index and overview
‚îú‚îÄ‚îÄ services/                           # 31 service components
‚îÇ   ‚îú‚îÄ‚îÄ INDEX.md                        # Services category index with detailed listings
‚îÇ   ‚îú‚îÄ‚îÄ 2IndicatorsDatabase.mdc         # Database service for technical indicators
‚îÇ   ‚îú‚îÄ‚îÄ BinanceServices.mdc             # Binance exchange integration
‚îÇ   ‚îú‚îÄ‚îÄ LiveAlerts.mdc                  # Real-time alert system
‚îÇ   ‚îú‚îÄ‚îÄ MainAPIServer.mdc               # Main API server service
‚îÇ   ‚îú‚îÄ‚îÄ MasterOrchestrationAgent.mdc    # Master orchestration service
‚îÇ   ‚îî‚îÄ‚îÄ [26 additional service files...]
‚îú‚îÄ‚îÄ libraries/                          # 47 library dependencies  
‚îÇ   ‚îú‚îÄ‚îÄ INDEX.md                        # Libraries category index with functionality groups
‚îÇ   ‚îú‚îÄ‚îÄ fastapi.mdc                     # FastAPI web framework
‚îÇ   ‚îú‚îÄ‚îÄ pandas.mdc                      # Data manipulation library
‚îÇ   ‚îú‚îÄ‚îÄ prometheus_client.mdc           # Prometheus metrics client
‚îÇ   ‚îî‚îÄ‚îÄ [44 additional library files...]
‚îú‚îÄ‚îÄ tools/                              # 19 development tools
‚îÇ   ‚îú‚îÄ‚îÄ INDEX.md                        # Tools category index with usage patterns
‚îÇ   ‚îú‚îÄ‚îÄ docker.mdc                      # Container platform
‚îÇ   ‚îú‚îÄ‚îÄ pytest.mdc                      # Testing framework
‚îÇ   ‚îî‚îÄ‚îÄ [17 additional tool files...]
‚îî‚îÄ‚îÄ integrations/                       # 19 service integrations
    ‚îú‚îÄ‚îÄ INDEX.md                        # Integrations category index with architecture patterns
    ‚îú‚îÄ‚îÄ binance-api-integration.mdc     # Exchange API integration
    ‚îú‚îÄ‚îÄ prometheus-integration.mdc      # Monitoring integration
    ‚îî‚îÄ‚îÄ [17 additional integration files...]
```

##### Organization Benefits:
- **Enhanced Tracking**: All 116 auto-discovered MDC files categorized and indexed
- **System Visibility**: Clear separation of services, libraries, tools, and integrations
- **Easy Navigation**: Category-specific index files with detailed listings
- **Maintenance Ready**: Organized structure for ongoing system management
- **Quick Reference**: Instant overview of each category with usage patterns

##### Discovery Statistics:
- **Total Auto-Discovered Files**: 116 MDC files organized
- **Services Category**: 31 service components (APIs, alerts, orchestration)
- **Libraries Category**: 47 dependencies (frameworks, data processing, monitoring)
- **Tools Category**: 19 development utilities (testing, build tools, containers)
- **Integrations Category**: 19 service connections (exchanges, databases, monitoring)

##### Index Documentation:
Each category folder contains comprehensive INDEX.md files with:
- **Detailed file listings** with descriptions and purposes
- **Category organization** grouped by functionality
- **Usage patterns** and architectural information
- **Quick reference** for development and maintenance

## Core Components

### 1. **Automatic Service Detection**
- **File System Monitoring**: Watches for new service files in orchestration directories
- **Registry Scanning**: Detects unregistered services in Service Registry
- **Configuration Parsing**: Reads service configurations from MDC files and startup scripts
- **Dependency Analysis**: Identifies service dependencies and startup order

### 2. **Intelligent Port Assignment**
- **Port Range Mapping**: Maps service types to appropriate port ranges
  - Frontend: 3400-3499
  - Backend: 8000-8099
  - Internal API: 8200-8299
  - Worker: 8300-8399
  - Orchestration: 8500-8599
- **Conflict Resolution**: Automatically resolves port conflicts
- **Permanent Assignment**: Assigns permanent ports after successful startup
- **Database Persistence**: Stores assignments in both legacy and Service Registry

### 3. **Master Orchestration Agent Integration**
- **Service Recognition**: Automatically recognizes new services
- **Topology Learning**: Updates service dependency maps
- **Health Monitoring**: Includes new services in health checks
- **Orchestration Management**: Manages new services in startup/shutdown cycles

## Workflow

### Phase 1: Service Detection
```python
@step: detect_new_services
def detect_new_services():
    """Detect new services that need port assignment"""
    # Scan orchestration directories
    new_services = scan_orchestration_directories()
    
    # Check Service Registry for unregistered services
    unregistered = check_service_registry()
    
    # Parse MDC files for service definitions
    mdc_services = parse_mdc_service_definitions()
    
    # Combine all detected services
    all_new_services = combine_detections(new_services, unregistered, mdc_services)
    
    return all_new_services
```

### Phase 2: Port Assignment
```python
@step: assign_ports_to_new_services
def assign_ports_to_new_services(new_services):
    """Assign unique ports to new services"""
    for service in new_services:
        # Determine service type and port range
        service_type = classify_service(service)
        port_range = get_port_range(service_type)
        
        # Find available port in range
        available_port = find_available_port(port_range)
        
        # Assign port to service
        assign_port_to_service(service, available_port)
        
        # Register in Service Registry
        register_service_in_registry(service, available_port)
        
        log_info(f"‚úÖ Assigned port {available_port} to {service.name}")
```

### Phase 3: Master Orchestration Agent Recognition
```python
@step: notify_master_orchestration_agent
def notify_master_orchestration_agent(new_services):
    """Notify Master Orchestration Agent of new services"""
    for service in new_services:
        # Update Master Orchestration Agent's service cache
        master_agent.update_service_cache(service)
        
        # Update dependency maps
        master_agent.update_dependency_maps(service)
        
        # Add to health monitoring
        master_agent.add_to_health_monitoring(service)
        
        # Update orchestration topology
        master_agent.update_topology(service)
        
        log_info(f"üéØ Master Orchestration Agent now recognizes {service.name}")
```

## Service Classification

### Frontend Services (3400-3499)
- **Criteria**: React/Vue applications, web interfaces, dashboards
- **Examples**: Professional Dashboard, Control UI, Monitoring Interface
- **Health Check**: HTTP endpoint on assigned port

### Backend Services (8000-8099)
- **Criteria**: API servers, data processing, business logic
- **Examples**: FastAPI servers, REST APIs, GraphQL endpoints
- **Health Check**: `/health` or `/api/health` endpoint

### Internal API Services (8200-8299)
- **Criteria**: Internal microservices, data services, utilities
- **Examples**: My Symbols Service, Test Service, Internal APIs
- **Health Check**: Service-specific health endpoints

### Worker Services (8300-8399)
- **Criteria**: Background workers, data processors, task queues
- **Examples**: Data collectors, alert processors, background tasks
- **Health Check**: Process status and queue health

### Orchestration Services (8500-8599)
- **Criteria**: Orchestration, coordination, management services
- **Examples**: Service Registry, Control UI, Orchestration Agents
- **Health Check**: Management API endpoints

## Integration Points

### Service Registry Integration
```python
@function: register_new_service
def register_new_service(service_name, port, service_type):
    """Register new service in Service Registry"""
    registry_data = {
        "name": service_name,
        "port": port,
        "type": service_type,
        "status": "DISCOVERED",
        "health_url": f"http://127.0.0.1:{port}/health",
        "start_cmd": generate_start_command(service_name),
        "dependencies": detect_dependencies(service_name)
    }
    
    # POST to Service Registry
    response = requests.post(
        "http://127.0.0.1:8610/services/register",
        json=registry_data,
        headers={"X-Token": REGISTRY_TOKEN}
    )
    
    return response.json()
```

### Port Manager Integration
```python
@function: update_port_manager
def update_port_manager(service_name, port):
    """Update Port Manager with new service assignment"""
    # Update legacy port registry
    port_registry.assign_port(service_name, port, permanent=True)
    
    # Update Service Registry
    service_registry.update_service_port(service_name, port)
    
    # Log assignment
    log_info(f"üìä Port {port} assigned to {service_name}")
```

### Master Orchestration Agent Integration
```python
@function: update_master_agent
def update_master_agent(service_info):
    """Update Master Orchestration Agent with new service"""
    # Add to service cache
    master_agent.services[service_info.name] = service_info
    
    # Update dependency maps
    master_agent.dependency_maps[service_info.name] = service_info.dependencies
    
    # Add to health monitoring
    master_agent.health_monitors[service_info.name] = {
        "url": service_info.health_url,
        "port": service_info.port,
        "status": "UNKNOWN"
    }
    
    # Update topology
    master_agent.update_topology()
    
    log_info(f"üéØ Master Agent now manages {service_info.name}")
```

## Automatic Discovery Triggers

### 1. **OrchestrationStart Trigger**
- Detects new services during startup sequence
- Assigns ports before service startup
- Notifies Master Orchestration Agent

### 2. **Service Registry Scan**
- Periodic scanning of Service Registry
- Identifies unregistered services
- Triggers automatic registration

### 3. **MDC File Changes**
- Watches for new service definitions in MDC files
- Parses service configurations
- Creates service registrations

### 4. **Manual Service Addition**
- Detects manually added service files
- Validates service configurations
- Integrates into orchestration system

## Error Handling

### Port Conflict Resolution
```python
@function: resolve_port_conflict
def resolve_port_conflict(service_name, desired_port):
    """Resolve port conflicts automatically"""
    if port_is_available(desired_port):
        return desired_port
    
    # Find next available port in range
    service_type = get_service_type(service_name)
    port_range = get_port_range(service_type)
    
    for port in range(port_range[0], port_range[1]):
        if port_is_available(port):
            log_warning(f"‚ö†Ô∏è Port {desired_port} in use, using {port} for {service_name}")
            return port
    
    raise Exception(f"No available ports in range {port_range} for {service_name}")
```

### Service Validation
```python
@function: validate_new_service
def validate_new_service(service_info):
    """Validate new service before integration"""
    # Check service configuration
    if not service_info.start_cmd:
        raise ValidationError(f"Missing start_cmd for {service_info.name}")
    
    # Validate health endpoint
    if not service_info.health_url:
        raise ValidationError(f"Missing health_url for {service_info.name}")
    
    # Check dependencies
    for dep in service_info.dependencies:
        if not service_exists(dep):
            log_warning(f"‚ö†Ô∏è Dependency {dep} not found for {service_info.name}")
    
    return True
```

## Monitoring and Logging

### Discovery Logging
```python
@function: log_service_discovery
def log_service_discovery(service_name, port, discovery_method):
    """Log service discovery events"""
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "service_name": service_name,
        "port": port,
        "discovery_method": discovery_method,
        "status": "DISCOVERED"
    }
    
    # Write to discovery log
    with open("service_discovery.log", "a") as f:
        f.write(json.dumps(log_entry) + "\n")
    
    log_info(f"üîç Discovered {service_name} on port {port} via {discovery_method}")
```

### Health Monitoring Integration
```python
@function: integrate_health_monitoring
def integrate_health_monitoring(service_info):
    """Integrate new service into health monitoring"""
    # Add to BackendDoctorAgent monitoring
    doctor_agent.add_service_monitoring(service_info)
    
    # Add to Service Registry health tracking
    service_registry.add_health_monitoring(service_info)
    
    # Update Master Orchestration Agent health checks
    master_agent.add_health_check(service_info)
    
    log_info(f"üè• Health monitoring enabled for {service_info.name}")
```

## Success Criteria

### Automatic Discovery
- ‚úÖ New services detected without manual intervention
- ‚úÖ Port assignment happens automatically
- ‚úÖ Service Registry updated automatically
- ‚úÖ Master Orchestration Agent recognizes new services

### Integration Quality
- ‚úÖ Services appear in orchestration topology
- ‚úÖ Health monitoring includes new services
- ‚úÖ Startup/shutdown cycles include new services
- ‚úÖ Dependency management works correctly

### Error Handling
- ‚úÖ Port conflicts resolved automatically
- ‚úÖ Invalid services rejected with clear errors
- ‚úÖ Missing dependencies logged as warnings
- ‚úÖ Failed integrations don't break existing services

## Usage Examples

### Adding a New Service
```bash
# 1. Create service file
touch zmart-api/new_service.py

# 2. Add service configuration to MDC file
echo "@service: new-service" >> .cursor/rules/NewService.mdc

# 3. Run orchestration - service will be automatically discovered
./START_ZmartBot.sh
```

### Manual Service Registration
```python
# Register service manually if needed
from service_discovery import register_new_service

register_new_service(
    service_name="my-new-service",
    port=8201,
    service_type="internal_api"
)
```

This system ensures that new services are seamlessly integrated into the ZmartBot orchestration without manual configuration, providing a truly dynamic and self-managing system.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---


## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**
