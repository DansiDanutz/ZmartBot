# ZmartDockerCompose.mdc


## Summary
ZmartBot Docker Compose configuration defining a comprehensive containerized microservices architecture with PostgreSQL, Redis, RabbitMQ, InfluxDB, monitoring stack (Prometheus/Grafana), and production-ready Nginx reverse proxy.

## Purpose
- Orchestrates complete ZmartBot application stack with dependencies
- Provides containerized development and production environments
- Integrates monitoring, messaging, and data storage services
- Enables scalable deployment with health checks and service dependencies
- Supports observability with metrics collection and visualization

## Description
- Orchestrates complete ZmartBot application stack with dependencies
- Provides containerized dev...

## Location
`/Users/dansidanutz/Desktop/ZmartBot/docker-compose.yml`

## Service Architecture

### Application Services

#### Main Application (zmartbot-app)
```yaml
app:
  build: .
  container_name: zmartbot-app
  restart: always
  ports: ["8000:8000"]
  environment:
    - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
    - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    - INFLUXDB_URL=http://influxdb:8086
    - RABBITMQ_URL=amqp://${RABBITMQ_DEFAULT_USER}:${RABBITMQ_DEFAULT_PASS}@rabbitmq:5672/
```

**Features**:
- **Port Exposure**: 8000 (FastAPI application)
- **Health Dependencies**: PostgreSQL, Redis, RabbitMQ
- **Volume Mounts**: Logs and data persistence
- **Environment**: Production configuration from .env.production

### Database Services

#### PostgreSQL (zmartbot-postgres)
```yaml
postgres:
  image: postgres:14-alpine
  container_name: zmartbot-postgres
  restart: always
  environment:
    - POSTGRES_USER=${POSTGRES_USER}
    - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    - POSTGRES_DB=${POSTGRES_DB}
  volumes:
    - postgres-data:/var/lib/postgresql/data
    - ./database_init.sql:/docker-entrypoint-initdb.d/init.sql
  ports: ["5432:5432"]
```

**Features**:
- **Image**: PostgreSQL 14 Alpine (lightweight)
- **Initialization**: Custom SQL script execution
- **Health Checks**: pg_isready validation
- **Data Persistence**: Named volume for data durability

#### Redis Cache (zmartbot-redis)
```yaml
redis:
  image: redis:7-alpine
  container_name: zmartbot-redis
  restart: always
  command: redis-server --requirepass ${REDIS_PASSWORD}
  volumes: [redis-data:/data]
  ports: ["6379:6379"]
```

**Features**:
- **Image**: Redis 7 Alpine (latest stable)
- **Security**: Password-protected access
- **Persistence**: Data volume for cache durability
- **Health Monitoring**: Redis ping validation

### Message Queue Services

#### RabbitMQ (zmartbot-rabbitmq)
```yaml
rabbitmq:
  image: rabbitmq:3.12-management-alpine
  container_name: zmartbot-rabbitmq
  restart: always
  environment:
    - RABBITMQ_DEFAULT_USER=${RABBITMQ_DEFAULT_USER}
    - RABBITMQ_DEFAULT_PASS=${RABBITMQ_DEFAULT_PASS}
  ports: ["5672:5672", "15672:15672"]
```

**Features**:
- **Management UI**: Web interface on port 15672
- **AMQP Protocol**: Message queue on port 5672
- **Authentication**: User credentials from environment
- **Health Checks**: RabbitMQ diagnostics validation

### Time Series Database

#### InfluxDB (zmartbot-influxdb)
```yaml
influxdb:
  image: influxdb:2.7-alpine
  container_name: zmartbot-influxdb
  restart: always
  environment:
    - DOCKER_INFLUXDB_INIT_MODE=setup
    - DOCKER_INFLUXDB_INIT_USERNAME=admin
    - DOCKER_INFLUXDB_INIT_PASSWORD=${INFLUXDB_ADMIN_PASSWORD}
    - DOCKER_INFLUXDB_INIT_ORG=zmartbot
    - DOCKER_INFLUXDB_INIT_BUCKET=metrics
    - DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=${INFLUXDB_ADMIN_TOKEN}
  ports: ["8086:8086"]
```

**Features**:
- **Automatic Setup**: Organization and bucket initialization
- **Token Authentication**: Secure API access
- **Metrics Storage**: Dedicated metrics bucket
- **Time Series**: Optimized for temporal data

### Monitoring Stack

#### Prometheus (zmartbot-prometheus)
```yaml
prometheus:
  image: prom/prometheus:latest
  container_name: zmartbot-prometheus
  restart: always
  volumes:
    - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    - prometheus-data:/prometheus
  command:
    - '--config.file=/etc/prometheus/prometheus.yml'
    - '--storage.tsdb.path=/prometheus'
  ports: ["9090:9090"]
```

**Features**:
- **Custom Configuration**: External prometheus.yml
- **Data Persistence**: Time series data storage
- **Service Discovery**: Automatic target discovery
- **Metrics Collection**: Application and system metrics

#### Grafana (zmartbot-grafana)
```yaml
grafana:
  image: grafana/grafana:latest
  container_name: zmartbot-grafana
  restart: always
  environment:
    - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER:-admin}
    - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
    - GF_INSTALL_PLUGINS=redis-datasource
  volumes:
    - grafana-data:/var/lib/grafana
    - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards
    - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources
  ports: ["3000:3000"]
```

**Features**:
- **Dashboard Provisioning**: Automated dashboard deployment
- **Data Source Integration**: Pre-configured Prometheus and Redis
- **Plugin Management**: Redis datasource plugin
- **Visualization**: Real-time monitoring dashboards

### Production Services

#### Nginx Reverse Proxy (zmartbot-nginx)
```yaml
nginx:
  image: nginx:alpine
  container_name: zmartbot-nginx
  restart: always
  volumes:
    - ./nginx.conf:/etc/nginx/nginx.conf:ro
    - ./ssl:/etc/nginx/ssl:ro
  ports: ["80:80", "443:443"]
  profiles: [production]
```

**Features**:
- **Load Balancing**: Reverse proxy for application services
- **SSL Termination**: HTTPS support with certificate management
- **Static Content**: Efficient static file serving
- **Production Profile**: Conditional deployment for production environments

## Network Architecture

### Service Network
```yaml
networks:
  zmartbot-network:
    driver: bridge
```

**Features**:
- **Service Isolation**: Dedicated network for ZmartBot services
- **Internal DNS**: Service name resolution
- **Security**: Network-level service isolation
- **Communication**: Inter-service communication optimization

## Data Persistence

### Volume Management
```yaml
volumes:
  postgres-data:    # PostgreSQL database files
  redis-data:       # Redis persistence files
  rabbitmq-data:    # RabbitMQ message storage
  influxdb-data:    # InfluxDB time series data
  prometheus-data:  # Prometheus metrics storage
  grafana-data:     # Grafana dashboards and config
```

**Features**:
- **Data Durability**: Persistent storage across container restarts
- **Backup Integration**: Volume-based backup strategies
- **Performance**: Optimized storage for each service type
- **Scalability**: Named volumes for easy management

## Health Check Configuration

### Service Health Validation
- **PostgreSQL**: `pg_isready -U ${POSTGRES_USER}`
- **Redis**: `redis-cli ping`
- **RabbitMQ**: `rabbitmq-diagnostics check_running`

**Health Check Parameters**:
- **Interval**: 10 seconds between checks
- **Timeout**: 5 seconds per check
- **Retries**: 5 attempts before marking unhealthy

## Environment Configuration

### Environment Variables
- **Database**: POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
- **Cache**: REDIS_PASSWORD
- **Message Queue**: RABBITMQ_DEFAULT_USER, RABBITMQ_DEFAULT_PASS
- **Monitoring**: GRAFANA_ADMIN_USER, GRAFANA_ADMIN_PASSWORD
- **Time Series**: INFLUXDB_ADMIN_PASSWORD, INFLUXDB_ADMIN_TOKEN

### Configuration Files
- **Environment**: `.env.production` for production settings
- **Monitoring**: `./monitoring/prometheus.yml` for metrics collection
- **Reverse Proxy**: `./nginx.conf` for production deployment
- **SSL**: `./ssl/` directory for certificate management

## Service Dependencies

### Dependency Graph
```
app → [postgres, redis, rabbitmq] (health checks)
prometheus → app (metrics collection)
grafana → [prometheus, influxdb] (data visualization)
nginx → app (reverse proxy)
```

### Startup Orchestration
- **Health Dependencies**: Services wait for dependencies to be healthy
- **Cascade Startup**: Proper service initialization order
- **Graceful Degradation**: Service isolation on failures

## Development vs Production

### Development Features
- **Port Exposure**: All services expose ports for direct access
- **Volume Mounts**: Configuration files mounted for development
- **Debug Access**: Direct database and cache access

### Production Features
- **Nginx Profile**: Production-only reverse proxy
- **SSL Configuration**: HTTPS termination and security
- **Environment Separation**: Production-specific configuration
- **Resource Limits**: Container resource constraints (configurable)

## Integration Points

### Application Integration
- **Database Connectivity**: PostgreSQL connection pooling
- **Cache Integration**: Redis for session and data caching
- **Message Processing**: RabbitMQ for asynchronous operations
- **Metrics Export**: Prometheus metrics endpoint
- **Time Series Storage**: InfluxDB for application metrics

### Monitoring Integration
- **Metrics Collection**: Prometheus scraping configuration
- **Dashboard Provisioning**: Automated Grafana dashboard deployment
- **Alert Management**: Integrated alerting through Grafana
- **Log Aggregation**: Centralized logging strategy

## Security Considerations
- **Network Isolation**: Services communicate through dedicated network
- **Authentication**: All services require authentication
- **SSL/TLS**: Production HTTPS encryption
- **Secret Management**: Environment-based secret configuration
- **Access Control**: Port exposure limited to necessary services

## Triggers
- **API endpoint requests**
- **Database events**
- **Health check requests**


## Requirements
- ✅ **Unique port assignment**
- ✅ **Database connectivity**
- ✅ **Complete MDC documentation**
- ✅ **Health endpoint implementation**
- ✅ **Master Orchestration integration**
