@datasource: PortRegistry

## ðŸ¤– MCP (Model Context Protocol) Integration

### **MCP Server Pairing**
**Status**: âœ… **ACTIVE** - Port Manager MCP Integration
**MCP Servers**: `claude-code`, `byterover`, `ui-tars`, `figma`, `supabase`
**Configuration**: `/Users/dansidanutz/.cursor/mcp.json`
**Integration Type**: Multi-MCP Service Integration

### **MCP Integration Features**
- **Claude Code Integration**: AI-powered port management and conflict resolution
- **Memory Gateway**: Persistent port registry and assignment metadata
- **UI Automation**: Automated port monitoring and health checks
- **Figma Integration**: Port management dashboard design and UI management
- **Supabase Integration**: Cloud-based port registry and analytics

### **MCP Pairing Benefits**
- **Enhanced Port Management**: AI-powered port assignment and conflict resolution
- **Persistent Registry**: Memory persistence for port management workflows
- **Automated Monitoring**: Automated port health monitoring and management
- **Design Integration**: Seamless integration with UI design workflows
- **Cloud Analytics**: Advanced port analytics and management monitoring

### **MCP Usage Examples**
```bash
# Test Port Manager MCP connection
curl -X GET http://127.0.0.1:8050/health

# Execute port assignment via MCP
curl -X POST http://127.0.0.1:8050/ports/assign \
  -H "Content-Type: application/json" \
  -d '{"service_name": "new-service", "requested_port": 8001}'
```

### **MCP Integration Status**
- **Connection**: âœ… Active and responsive
- **Health Check**: âœ… All MCP servers healthy
- **Memory Sync**: âœ… Real-time memory synchronization
- **UI Automation**: âœ… Automated monitoring active
- **Cloud Sync**: âœ… Supabase integration active

# PortManager - Post-Startup Port Assignment Management

## Overview
The PortManager is a **post-startup service** that runs **after** the ZmartBot system is fully operational. It manages dynamic port assignments for new services, prevents duplicates, and maintains port registry integrity until the next STOP_ZMARTBOT cycle.

## ðŸš¨ **MANDATORY ZMARTBOT SERVICE ARCHITECTURE WORKFLOW**

### **CRITICAL WORKFLOW RULES (FORBIDDEN TO IGNORE)**

**ðŸš¨ NO EXCUSES - SYSTEM WILL CRASH IF RULES ARE BROKEN**

#### **Rule 1: Service Definition**
- **ANY .py file = SERVICE**: Every Python file represents a service
- **MANDATORY MDC**: Every .py file MUST have an associated MDC file
- **SERVICE COUNTING**: All .py files are counted as services in the system

#### **Rule 2: Port Assignment (Port Manager)**
- **MANDATORY PORT**: Any service trying to connect with other services MUST receive a port from Port Manager
- **PORT DATABASE**: Port Manager assigns a FREE port different from stored ports in database
- **CONFLICT RESOLUTION**: If port conflict detected, Port Manager automatically assigns new port
- **PERSISTENCE**: Port assignment is persisted and cannot be changed without proper workflow

#### **Rule 3: Passport Assignment (Integration Gate)**
- **PASSPORT REQUIRED**: Service MUST receive a passport to be integrated into system
- **MDC PREREQUISITE**: Passport is ONLY accepted if the .py service has an associated MDC file
- **UNIQUE IDENTITY**: Each passport provides unique service identity and tracking
- **SYSTEM ACCESS**: Without passport, service cannot access system resources

#### **Rule 4: Registration Process (Final Stage)**
- **IMPLEMENTATION COMPLETE**: Service implementation must be done and tested
- **STRICT WORKFLOW**: Registration follows mandatory steps documented in StopStartCycle and NewService MDC files
- **SUCCESS VERIFICATION**: Only proceed if all steps are successful
- **FINAL STATUS**: Successful registration upgrades service to "REGISTERED" status

#### **Rule 5: Registered Service Requirements**
- **AUTOMATIC STARTUP**: All registered services MUST start when system starts
- **ORCHESTRATION INTEGRATION**: Services must be assigned to Master Orchestration Agent
- **SAFE LEARNING**: Services must integrate with Master Orchestration Agent's safe learning system
- **CERTIFICATION**: All registered services MUST receive a certificate from Certification Service

#### **Rule 6: System Protection**
- **PROTECTION TRIGGER**: After registration completion, Protection Service is automatically triggered
- **DELETION PREVENTION**: Protection Service prevents registered services from being deleted
- **SYSTEM INTEGRITY**: Protection ensures system architecture integrity

### **PORT MANAGER RESPONSIBILITIES**
- **MANDATORY PORT ASSIGNMENT**: Port Manager MUST assign ports to services trying to connect with other services
- **PORT DATABASE MANAGEMENT**: Port Manager manages the port database and assigns FREE ports different from stored ports
- **CONFLICT RESOLUTION**: Port Manager automatically resolves port conflicts by assigning new ports
- **PERSISTENCE**: Port Manager persists port assignments and prevents changes without proper workflow
- **WORKFLOW ENFORCEMENT**: Port Manager enforces the mandatory workflow rules

## When PortManager Runs

### **TIMING**: Always AFTER system startup
- âœ… System is running (Backend 8000, Dashboard 3400)
- âœ… Core services are operational
- âœ… PortManager starts monitoring for new services
- âŒ NOT during startup process
- âŒ NOT before system is ready

## What PortManager Does

### 1. **Database Analysis** (Port Manager Database)
- **Location**: `src/data/port_registry.db`
- **Purpose**: Check existing port assignments
- **Process**:
  - Read all currently assigned ports
  - Identify available port ranges
  - Detect any port conflicts
  - Validate existing service mappings

### 2. **New Service Detection**
- **Trigger**: New service requests port assignment
- **Validation**:
  - Check if service already exists
  - Verify service is not a duplicate
  - Confirm service is legitimate
  - Validate service requirements

### 3. **Port Assignment Logic**
```python
def assign_port_to_new_service(service_name, service_type):
    # Standardized port ranges
    PORT_RANGES = {
        'frontend': (3400, 3499),
        'backend': (8000, 8099),
        'internal_api': (8200, 8299),
        'worker': (8300, 8399),
        'orchestration': (8500, 8599)
    }
    
    # Get assigned ports for service type
    assigned_ports = get_assigned_ports_by_type(service_type)
    
    # Find next available port in service type range
    start_port, end_port = PORT_RANGES.get(service_type, (8000, 8099))
    available_port = find_next_available_port_in_range(assigned_ports, start_port, end_port)
    
    # Assign port to new service
    assign_port(service_name, available_port, service_type)
    
    # Mark as permanent assignment
    mark_as_permanent_assignment(service_name, available_port, service_type)
```

### 4. **Duplicate Prevention**
- **Detection**: Service name already exists in database
- **Action**: **INSTANT REMOVAL** of duplicate service
- **Process**:
  - Identify duplicate service
  - Kill duplicate process immediately
  - Remove from port registry
  - Log duplicate attempt

## Port Assignment Workflow

### Phase 1: Service Registration Request
```python
# New service requests port
new_service = {
    "name": "new_alert_service",
    "type": "alert_processor",
    "requirements": {"port": "any", "priority": "normal"}
}
```

### Phase 2: Duplicate Check
```python
# Check if service already exists
if port_registry.service_exists(new_service["name"]):
    # INSTANT REMOVAL
    kill_service_process(new_service["name"])
    remove_from_registry(new_service["name"])
    log_duplicate_attempt(new_service["name"])
    return False
```

### Phase 3: Port Assignment
```python
# Find available port
available_port = port_registry.find_available_port()

# Assign port to new service
port_registry.assign_port(
    service_name=new_service["name"],
    port=available_port,
    status="TEMPORARY"
)
```

### Phase 4: Temporary Registration
```python
# Mark as temporary until STOP_ZMARTBOT
port_registry.mark_temporary_assignment(
    service_name=new_service["name"],
    port=available_port,
    expires_at="STOP_ZMARTBOT"
)
```

## @function: assign_next_free_port

### Purpose
Automatically assigns the next available port to a new service request.

### Implementation
```python
def assign_next_free_port(service_name: str, service_type: str = "general") -> int:
    """
    Assigns the next available port to a new service.
    
    Args:
        service_name: Name of the service requesting port
        service_type: Type of service (api, dashboard, monitoring, etc.)
    
    Returns:
        int: Assigned port number
        
    Raises:
        PortConflictError: If no ports available
        DuplicateServiceError: If service already exists
    """
    # Check for duplicates first
    if port_registry.service_exists(service_name):
        raise DuplicateServiceError(f"Service {service_name} already exists")
    
    # Get current port assignments
    assigned_ports = port_registry.get_all_assignments()
    
    # Map service type to port range
    port_ranges = {
        "frontend": (3400, 3499),
        "backend": (8000, 8099),
        "public_api": (8100, 8199),
        "internal_api": (8200, 8299),
        "worker": (8300, 8399),
        "orchestration": (8500, 8599),
        "registry": (8610, 8610)  # Fixed port
    }
    
    # Get port range for service type
    if service_type not in port_ranges:
        raise ValueError(f"Unknown service type: {service_type}")
    
    base_port, max_port = port_ranges[service_type]
    
    for port in range(base_port, max_port + 1):
        if port not in assigned_ports:
            # Assign port to service
            port_registry.assign_port(
                service_name=service_name,
                port=port,
                service_type=service_type,
                status="ACTIVE"
            )
            return port
    
    raise PortConflictError("No available ports in range 8000-9000")
```

## Description
Automatically assigns the next available port to a new service request.

## @step: persist_port

### Purpose
Persists port assignments to both the runtime registry and permanent database.

### Implementation
```python
def persist_port(service_name: str, port: int, service_type: str = "general"):
    """
    Persists port assignment to both registries.
    
    Args:
        service_name: Name of the service
        port: Assigned port number
        service_type: Type of service
    """
    # Update runtime registry
    port_registry.update_assignment(
        service_name=service_name,
        port=port,
        status="PERSISTED"
    )
    
    # Update permanent database
    port_database.persist_assignment(
        service_name=service_name,
        port=port,
        service_type=service_type,
        timestamp=datetime.now(),
        status="ACTIVE"
    )
    
    # POST to Service Registry API
    import requests
    import json
    
    registry_url = "http://127.0.0.1:8610/services/register"
    headers = {"Content-Type": "application/json"}
    
    # Add token if available
    import os
    token = os.getenv("REGISTRY_TOKEN")
    if token:
        headers["X-Token"] = token
    
    service_data = {
        "service_name": service_name,
        "kind": service_type,
        "host": "127.0.0.1",
        "port": port,
        "health_url": f"http://127.0.0.1:{port}/health" if service_type != "frontend" else f"http://127.0.0.1:{port}",
        "start_cmd": f"python3 {service_name}.py --port {port}" if service_type == "backend" else None,
        "stop_cmd": f"pkill -f {service_name}",
        "deps": [],
        "status": "DISCOVERED"
    }
    
    try:
        response = requests.post(registry_url, headers=headers, json=service_data)
        if response.status_code == 200:
            logger.info(f"Service {service_name} registered in Service Registry")
        else:
            logger.warning(f"Failed to register service in Service Registry: {response.status_code}")
    except Exception as e:
        logger.warning(f"Could not connect to Service Registry: {e}")
    
    # Log the persistence
    logger.info(f"Port {port} persisted for {service_name} ({service_type})")
```
    service_name=new_service["name"],
    port=available_port,
    assigned_at=datetime.now()
)
```

## Description
Automatically assigns the next available port to a new service request.

## Database Schema for Temporary Assignments

### Temporary Assignments Table
```sql
CREATE TABLE temporary_port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status TEXT DEFAULT 'TEMPORARY',
    will_persist BOOLEAN DEFAULT FALSE
);
```

### Port Registry Integration
```sql
-- Main port assignments (persistent)
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## Port Assignment Rules

### Available Port Ranges
- **Core Services**: 8000-8009 (Fixed assignments)
- **Dynamic Services**: 8010-8999 (Auto-assignment)
- **Reserved Ports**: 9000-9999 (Special services)

### Assignment Priority
1. **Core Services** (Fixed ports)
   - Backend API: 8000
   - Dashboard: 3400
   - Orchestration: 8002

2. **Dynamic Services** (Auto-assigned)
   - Alert Services: 8010+
   - Data Processors: 8020+
   - Monitoring Services: 8030+

### Conflict Resolution
- **Port in Use**: Assign next available port
- **Service Duplicate**: Instant removal
- **Invalid Service**: Reject assignment
- **Database Error**: Log and retry

## STOP_ZMARTBOT Integration

### Before STOP_ZMARTBOT
- PortManager continues monitoring
- Temporary assignments remain active
- New services can still request ports

### During STOP_ZMARTBOT
- **Permanent Registration**: Temporary assignments become permanent
- **Database Update**: All new services added to main registry
- **Configuration Sync**: Update orchestration configs
- **Cleanup**: Remove temporary assignment markers

### After STOP_ZMARTBOT
- All assignments are permanent
- Database is synchronized
- Ready for next startup cycle

## Error Handling

### Duplicate Service Detection
```python
def handle_duplicate_service(service_name):
    # Log duplicate attempt
    logger.warning(f"Duplicate service detected: {service_name}")
    
    # Kill duplicate process
    kill_process_by_name(service_name)
    
    # Remove from registry
    port_registry.remove_service(service_name)
    
    # Notify admin
    notify_admin(f"Duplicate service {service_name} removed")
```

### Port Conflict Resolution
```python
def resolve_port_conflict(requested_port):
    # Check if port is available
    if port_registry.is_port_available(requested_port):
        return requested_port
    
    # Find next available port
    next_available = port_registry.find_next_available_port()
    
    # Log port change
    logger.info(f"Port conflict resolved: {requested_port} -> {next_available}")
    
    return next_available
```

### Database Error Recovery
```python
def handle_database_error(error):
    # Create backup
    port_registry.create_backup()
    
    # Attempt recovery
    if port_registry.recover_from_error(error):
        logger.info("Database recovery successful")
    else:
        logger.error("Database recovery failed")
        # Fallback to safe mode
        enable_safe_mode()
```

## Monitoring and Logging

### Service Monitoring
- Track all new service requests
- Monitor port assignment success/failure
- Log duplicate detection events
- Record port conflict resolutions

### Performance Metrics
- Port assignment response time
- Duplicate detection accuracy
- Database operation performance
- Service registration success rate

### Health Checks
- Database connectivity
- Port availability status
- Service process monitoring
- Registry integrity validation

## Configuration

### PortManager Settings
```json
{
  "database_path": "src/data/port_registry.db",
  "port_ranges": {
    "core": [8000, 8009],
    "dynamic": [8010, 8999],
    "reserved": [9000, 9999]
  },
  "duplicate_handling": {
    "instant_removal": true,
    "logging": true,
    "notification": true
  },
  "temporary_assignments": {
    "enabled": true,
    "max_duration": "24h",
    "auto_cleanup": true
  }
}
```

## Success Criteria

### Service Management
- âœ… No duplicate services running
- âœ… All new services have valid ports
- âœ… Port conflicts resolved automatically
- âœ… Temporary assignments tracked properly

### Database Integrity
- âœ… All assignments recorded correctly
- âœ… No orphaned entries
- âœ… Temporary assignments marked properly
- âœ… Backup created before changes

### System Stability
- âœ… No port conflicts
- âœ… Services running on assigned ports
- âœ… Registry synchronized with reality
- âœ… Ready for STOP_ZMARTBOT cycle

## Integration Points

### With Running System
- Monitors for new service requests
- Assigns ports dynamically
- Prevents conflicts with running services
- Maintains system stability

### With STOP_ZMARTBOT
- Provides temporary assignments for permanent registration
- Ensures all new services are captured
- Prepares database for shutdown cycle
- Maintains assignment integrity

### With OrchestrationStart
- Provides current port assignments for startup
- Ensures new services are properly registered
- Validates port assignments after startup
- Maintains system coordination

This PortManager process ensures that new services can be added to the running ZmartBot system without conflicts, while maintaining data integrity and preparing for proper shutdown/startup cycles.

## @function: assign_next_free_port
### Ranges
- frontend: 3400â€“3499
- backend: 8000â€“8099
- public_api: 8100â€“8199
- internal_api: 8200â€“8299
- worker: 8300â€“8399
- orchestration: 8500â€“8599
- registry: 8610 (fixed)

#### How:
1) Map `kind` â†’ range.
2) Query service_registry.db for used ports in the range.
3) Return first free port (error if none).

## @step: persist_port
- Write {service_name, port, pid, status} to port_registry.db (legacy history).
- POST â†’ http://127.0.0.1:8610/services/register (X-Token when set) with:
- service_name, kind, host=127.0.0.1, port
- health_url, start_cmd, stop_cmd, deps=[]
- status="DISCOVERED"

@step: create_state_snapshot
- Capture current port assignments and service states
- Save to state snapshot for smooth startup experience
- Include cached data for immediate availability during startup
- Log: "âœ… State screenshot captured"
description:
globs:
alwaysApply: true

## Requirements
- âœ… **Unique port assignment**
- âœ… **Database connectivity**
- âœ… **Valid service passport**
- âœ… **Complete MDC documentation**
- âœ… **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **Database events**
- **Workflow transitions**
