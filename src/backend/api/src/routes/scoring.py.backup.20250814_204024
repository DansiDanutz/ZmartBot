#!/usr/bin/env python3
"""
Scoring Routes
API routes for comprehensive scoring system
"""

from fastapi import APIRouter, HTTPException, Depends
from typing import Dict, Any, List, Optional
import logging

from ..services.integrated_scoring_system import IntegratedScoringSystem
from ..services.calibrated_scoring_service import CalibratedScoringService
from ..services.unified_riskmetric import UnifiedRiskMetric as RiskMetricService

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/scoring", tags=["scoring"])

# Initialize services
integrated_scoring = IntegratedScoringSystem()
calibrated_scoring = CalibratedScoringService()
riskmetric_service = RiskMetricService()

@router.get("/health")
async def get_scoring_health():
    """Get scoring system health status"""
    try:
        return await integrated_scoring.get_scoring_health()
    except Exception as e:
        logger.error(f"Error getting scoring health: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/comprehensive/{symbol}")
async def get_comprehensive_score(symbol: str):
    """Get comprehensive score for a symbol"""
    try:
        return await integrated_scoring.get_comprehensive_score(symbol.upper())
    except Exception as e:
        logger.error(f"Error getting comprehensive score for {symbol}: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/calibrated/{symbol}")
async def get_calibrated_score(symbol: str):
    """Get calibrated score for a symbol"""
    try:
        independent_scores = await calibrated_scoring.get_independent_scores(symbol.upper())
        
        if not independent_scores:
            raise HTTPException(status_code=404, detail=f"No scores found for {symbol}")
        
        # Convert IndependentScores to API response format
        available_scores = independent_scores.get_available_scores()
        total_score = sum(
            component_score.score 
            for component_score in available_scores.values() 
            if component_score and hasattr(component_score, 'score')
        )
        
        return {
            "symbol": symbol.upper(),
            "total_score": total_score,
            "components": {
                name: {
                    "score": score.score,
                    "confidence": getattr(score, 'confidence', 0.0),
                    "details": getattr(score, 'details', {})
                }
                for name, score in available_scores.items()
                if score and hasattr(score, 'score')
            },
            "timestamp": independent_scores.timestamp.isoformat()
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting calibrated score for {symbol}: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/riskmetric/{symbol}")
async def get_riskmetric_score(symbol: str):
    """Get RiskMetric score for a symbol"""
    try:
        assessment = await riskmetric_service.assess_risk(symbol.upper())
        if assessment:
            # Convert to scoring component format
            return {
                "symbol": symbol.upper(),
                "score": assessment.score,
                "risk_value": assessment.risk_value,
                "signal": assessment.signal,
                "tradeable": assessment.tradeable
            }
        else:
            raise HTTPException(status_code=404, detail=f"Symbol {symbol} not found")
    except Exception as e:
        logger.error(f"Error getting RiskMetric score for {symbol}: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/batch")
async def get_batch_scores(symbols: str):
    """Get scores for multiple symbols"""
    try:
        symbol_list = [s.strip().upper() for s in symbols.split(',')]
        results = {}
        
        for symbol in symbol_list:
            results[symbol] = await integrated_scoring.get_comprehensive_score(symbol)
        
        return results
    except Exception as e:
        logger.error(f"Error getting batch scores: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/leaderboard")
async def get_scoring_leaderboard():
    """Get top scoring symbols"""
    try:
        # This would get scores for all symbols and rank them
        return {
            'leaderboard': [],
            'last_updated': None,
            'message': 'Leaderboard functionality not yet implemented'
        }
    except Exception as e:
        logger.error(f"Error getting scoring leaderboard: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))