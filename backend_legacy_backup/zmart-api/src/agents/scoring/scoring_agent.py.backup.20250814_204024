"""
Zmart Trading Bot Platform - Win Rate Scoring Agent
Modern scoring agent using win rate correlation and dynamic weighting

WIN RATE CORRELATION RULE:
- Score = Win Rate Percentage (80 points = 80% win rate)
- Multi-timeframe analysis: 24h, 7d, 1m
- 95%+ = Exceptional opportunity (All in trade)
- 90%+ = Infrequent opportunity (High confidence)
- 80%+ = Good opportunity (Enter trade)
"""

import asyncio
import logging
from datetime import datetime
from typing import Dict, Any, List, Optional
from dataclasses import dataclass

from src.utils.event_bus import EventBus, Event, EventType
from .win_rate_scoring_standard import win_rate_standard, TradeOpportunity

logger = logging.getLogger(__name__)

@dataclass
class ScoringResult:
    """Result of win rate scoring with dynamic weighting"""
    symbol: str
    total_score: float  # 100-point scale (win rate percentage)
    kingfisher_score: Optional[float] = None
    cryptometer_score: Optional[float] = None
    riskmetric_score: Optional[float] = None
    confidence: float = 0.0
    signal: str = "Hold"
    timestamp: Optional[datetime] = None
    dynamic_weights: Optional[Dict[str, float]] = None
    market_condition: Optional[str] = None
    
    # Win rate specific fields
    win_rate_percentage: Optional[float] = None  # Same as total_score for clarity
    opportunity_level: Optional[str] = None  # exceptional, infrequent, good, etc.
    timeframe_analysis: Optional[Dict[str, Any]] = None  # 24h, 7d, 1m analysis

class ScoringAgent:
    """
    Win Rate Scoring Agent using dynamic weighting system
    
    WIN RATE CORRELATION RULE:
    - Each score represents win rate percentage (80 points = 80% win rate)
    - Multi-timeframe analysis: 24h, 7d, 1m for each source
    - 95%+ = Exceptional opportunity (All in trade)
    - 90%+ = Infrequent opportunity (High confidence)
    - 80%+ = Good opportunity (Enter trade)
    
    Features:
    - Dynamic weight calculation based on data quality and market conditions
    - 100-point win rate scoring scale for all sources
    - Market condition awareness
    - Intelligent confidence assessment
    - Multi-timeframe win rate predictions
    """
    
    def __init__(self):
        """Initialize the scoring agent with dynamic scoring integration"""
        self.agent_id = "scoring_agent"
        self.status = "stopped"
        self.event_bus = EventBus()
        
        # Import the dynamic scoring system
        from ...services.integrated_scoring_system import IntegratedScoringSystem
        self.integrated_scoring = IntegratedScoringSystem()
        
        # Win rate scoring standard
        self.win_rate_standard = win_rate_standard
        
        # Task management
        self._running = False
        self._tasks: List[asyncio.Task] = []
        
        logger.info("Win Rate Scoring Agent initialized with dynamic weighting system")
    
    async def start(self):
        """Start the scoring agent"""
        if self._running:
            logger.warning("Scoring agent is already running")
            return
        
        self._running = True
        self.status = "running"
        
        # Start background tasks
        self._tasks = [
            asyncio.create_task(self._scoring_loop())
        ]
        
        logger.info("Scoring agent started")
    
    async def stop(self):
        """Stop the scoring agent"""
        if not self._running:
            logger.warning("Scoring agent is not running")
            return
        
        self._running = False
        self.status = "stopped"
        
        # Cancel all tasks
        for task in self._tasks:
            task.cancel()
        
        await asyncio.gather(*self._tasks, return_exceptions=True)
        self._tasks = []
        
        logger.info("Scoring agent stopped")
    
    async def score_signal(self, symbol: str, signal_data: Dict[str, Any]) -> ScoringResult:
        """
        Score a trading signal using win rate correlation and dynamic weighting
        
        WIN RATE CORRELATION: Score = Win Rate Percentage
        - 80 points = 80% win rate
        - 90 points = 90% win rate (infrequent opportunity)
        - 95 points = 95% win rate (exceptional opportunity - all in)
        
        Uses the new dynamic scoring agent for intelligent weight calculation
        Returns comprehensive scoring result with confidence assessment
        """
        try:
            # Extract win rate scores from signal data (expecting 100-point scale = win rate %)
            kingfisher_score = signal_data.get('kingfisher_score')
            riskmetric_score = signal_data.get('riskmetric_score') 
            cryptometer_score = signal_data.get('cryptometer_score')
            
            # Check for multi-timeframe data
            kingfisher_timeframes = signal_data.get('kingfisher_timeframes')
            cryptometer_timeframes = signal_data.get('cryptometer_timeframes')
            riskmetric_timeframes = signal_data.get('riskmetric_timeframes')
            
            # Use multi-timeframe analysis if available
            if any([kingfisher_timeframes, cryptometer_timeframes, riskmetric_timeframes]):
                dynamic_result = await self.integrated_scoring.dynamic_agent.calculate_multi_timeframe_win_rate(
                    symbol=symbol,
                    kingfisher_timeframes=kingfisher_timeframes,
                    cryptometer_timeframes=cryptometer_timeframes,
                    riskmetric_timeframes=riskmetric_timeframes
                )
            else:
                # Use single score analysis
                dynamic_result = await self.integrated_scoring.dynamic_agent.calculate_dynamic_score(
                    symbol=symbol,
                    kingfisher_score=kingfisher_score,
                    cryptometer_score=cryptometer_score,
                    riskmetric_score=riskmetric_score,
                    kingfisher_metadata=signal_data.get('kingfisher_metadata', {}),
                    cryptometer_metadata=signal_data.get('cryptometer_metadata', {}),
                    riskmetric_metadata=signal_data.get('riskmetric_metadata', {})
                )
            
            # Classify opportunity level based on win rate
            opportunity_level = self.win_rate_standard.classify_opportunity(dynamic_result.final_score)
            
            result = ScoringResult(
                symbol=symbol,
                total_score=dynamic_result.final_score,  # 100-point scale (win rate %)
                kingfisher_score=kingfisher_score,
                riskmetric_score=riskmetric_score,
                cryptometer_score=cryptometer_score,
                confidence=dynamic_result.overall_confidence,
                signal=dynamic_result.signal,
                timestamp=dynamic_result.timestamp,
                dynamic_weights={
                    "kingfisher": dynamic_result.dynamic_weights.kingfisher_weight,
                    "cryptometer": dynamic_result.dynamic_weights.cryptometer_weight,
                    "riskmetric": dynamic_result.dynamic_weights.riskmetric_weight
                },
                market_condition=dynamic_result.market_condition.value,
                win_rate_percentage=dynamic_result.final_score,  # Explicit win rate
                opportunity_level=opportunity_level.value,
                timeframe_analysis=dynamic_result.trading_recommendations
            )
            
            # Emit scoring event with win rate data
            scoring_event = Event(
                type=EventType.SIGNAL_PROCESSED,
                data={
                    "symbol": symbol,
                    "final_score": dynamic_result.final_score,  # 100-point scale
                    "win_rate_percentage": dynamic_result.final_score,  # Explicit win rate
                    "opportunity_level": opportunity_level.value,
                    "confidence": dynamic_result.overall_confidence,
                    "signal": dynamic_result.signal,
                    "dynamic_weights": {
                        "kingfisher": dynamic_result.dynamic_weights.kingfisher_weight,
                        "cryptometer": dynamic_result.dynamic_weights.cryptometer_weight,
                        "riskmetric": dynamic_result.dynamic_weights.riskmetric_weight,
                        "reasoning": dynamic_result.dynamic_weights.reasoning
                    },
                    "market_condition": dynamic_result.market_condition.value,
                    "trading_recommendations": dynamic_result.trading_recommendations,
                    "timestamp": dynamic_result.timestamp.isoformat()
                }
            )
            await self.event_bus.emit(scoring_event)
            
            return result
            
        except Exception as e:
            logger.error(f"Error scoring signal for {symbol}: {e}")
            return ScoringResult(
                symbol=symbol,
                total_score=50.0,  # Neutral 50% win rate on error
                confidence=0.0,
                signal="Hold",
                timestamp=datetime.now(),
                win_rate_percentage=50.0,
                opportunity_level="avoid"
            )
    
    def _generate_signal(self, score: float) -> str:
        """Generate trading signal based on 100-point score"""
        if score >= 80:
            return "Strong Buy"
        elif score >= 65:
            return "Buy"
        elif score >= 55:
            return "Weak Buy"
        elif score >= 45:
            return "Hold"
        elif score >= 35:
            return "Weak Sell"
        elif score >= 20:
            return "Sell"
        else:
            return "Strong Sell"
    
    async def _scoring_loop(self):
        """Background task for continuous scoring"""
        while self._running:
            try:
                await asyncio.sleep(60)  # Process every minute
                
                # In a real implementation, this would process incoming signals
                # For now, it's a placeholder for continuous scoring
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in scoring loop: {e}")
    
    async def get_status(self) -> Dict[str, Any]:
        """Get current agent status including dynamic scoring system"""
        try:
            dynamic_status = await self.integrated_scoring.get_scoring_health()
            
            return {
                "agent_id": self.agent_id,
                "status": self.status,
                "scoring_system": "dynamic_weighting",
                "score_scale": "100_point",
                "dynamic_agent_status": dynamic_status.get('dynamic_agent', {}),
                "market_condition": dynamic_status.get('dynamic_agent', {}).get('market_condition', 'unknown'),
                "reliability_scores": dynamic_status.get('dynamic_agent', {}).get('reliability_scores', {}),
                "last_updated": datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Error getting status: {e}")
            return {
                "agent_id": self.agent_id,
                "status": self.status,
                "scoring_system": "dynamic_weighting",
                "error": str(e),
                "last_updated": datetime.now().isoformat()
            } 