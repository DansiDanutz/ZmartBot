-- ============================================================================
-- Supabase B: Zmart Trading Database
-- Purpose: Trading data, indicators, signals, risk metrics, win rates
-- ============================================================================

-- Extension: Ensure UUID support
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================================
-- Table: watchers
-- Purpose: Active symbol watchers (synced from Supabase A user_symbols)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.watchers (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL,  -- No FK to auth.users (different database)
  symbol TEXT NOT NULL CHECK (LENGTH(symbol) > 0),
  timeframe TEXT NOT NULL DEFAULT '1h' CHECK (timeframe IN ('1m', '5m', '15m', '30m', '1h', '4h', '1d', '1w')),
  strategy JSONB DEFAULT '{}'::JSONB,
  active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, symbol, timeframe)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_watchers_user_id ON public.watchers(user_id);
CREATE INDEX IF NOT EXISTS idx_watchers_symbol ON public.watchers(symbol);
CREATE INDEX IF NOT EXISTS idx_watchers_active ON public.watchers(active) WHERE active = TRUE;
CREATE INDEX IF NOT EXISTS idx_watchers_symbol_timeframe ON public.watchers(symbol, timeframe) WHERE active = TRUE;

-- ============================================================================
-- Table: indicators
-- Purpose: Technical indicator data from external APIs (Cryptometer, etc.)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.indicators (
  id BIGSERIAL PRIMARY KEY,
  symbol TEXT NOT NULL,
  timeframe TEXT NOT NULL,
  at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  data JSONB NOT NULL,  -- {rsi: 65, macd: {...}, ema: {...}, etc}
  source TEXT DEFAULT 'cryptometer' CHECK (source IN ('cryptometer', 'kingfisher', 'internal')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(symbol, timeframe, at, source)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_indicators_symbol_timeframe ON public.indicators(symbol, timeframe);
CREATE INDEX IF NOT EXISTS idx_indicators_at ON public.indicators(at DESC);
CREATE INDEX IF NOT EXISTS idx_indicators_symbol_at ON public.indicators(symbol, at DESC);

-- ============================================================================
-- Table: risk_metric
-- Purpose: Risk assessment data (volatility, drawdown, etc.)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.risk_metric (
  id BIGSERIAL PRIMARY KEY,
  symbol TEXT NOT NULL,
  at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  metrics JSONB NOT NULL,  -- {volatility: 0.05, max_drawdown: 0.15, sharpe: 1.8, etc}
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(symbol, at)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_risk_metric_symbol ON public.risk_metric(symbol);
CREATE INDEX IF NOT EXISTS idx_risk_metric_at ON public.risk_metric(at DESC);
CREATE INDEX IF NOT EXISTS idx_risk_metric_symbol_at ON public.risk_metric(symbol, at DESC);

-- ============================================================================
-- Table: liq_clusters
-- Purpose: Liquidation cluster analysis (from KingFisher or similar)
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.liq_clusters (
  id BIGSERIAL PRIMARY KEY,
  symbol TEXT NOT NULL,
  at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  clusters JSONB NOT NULL,  -- [{price: 45000, volume: 1.2M, side: 'long'}, ...]
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_liq_clusters_symbol ON public.liq_clusters(symbol);
CREATE INDEX IF NOT EXISTS idx_liq_clusters_at ON public.liq_clusters(at DESC);

-- ============================================================================
-- Table: signals
-- Purpose: Trading signals generated by strategy algorithms
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.signals (
  id BIGSERIAL PRIMARY KEY,
  symbol TEXT NOT NULL,
  timeframe TEXT NOT NULL,
  at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  direction TEXT CHECK (direction IN ('long', 'short', 'flat', 'hold')),
  score NUMERIC NOT NULL CHECK (score >= 0 AND score <= 1),  -- 0-1 confidence score
  entry_price NUMERIC,
  stop_loss NUMERIC,
  take_profit NUMERIC[],  -- Array of multiple TP levels
  confidence NUMERIC CHECK (confidence >= 0 AND confidence <= 1),
  reasons JSONB,  -- {rsi_oversold: true, macd_bullish_cross: true, etc}
  user_id UUID,  -- NULL for global signals, specific user for custom strategies
  strategy_version TEXT DEFAULT 'v1',
  metadata JSONB DEFAULT '{}'::JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(symbol, timeframe, at, COALESCE(user_id, '00000000-0000-0000-0000-000000000000'::UUID), strategy_version)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_signals_symbol_timeframe ON public.signals(symbol, timeframe);
CREATE INDEX IF NOT EXISTS idx_signals_at ON public.signals(at DESC);
CREATE INDEX IF NOT EXISTS idx_signals_user_id ON public.signals(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_signals_direction ON public.signals(direction);
CREATE INDEX IF NOT EXISTS idx_signals_symbol_at ON public.signals(symbol, at DESC);

-- ============================================================================
-- Table: win_rate
-- Purpose: Historical win rate statistics for signals
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.win_rate (
  id BIGSERIAL PRIMARY KEY,
  symbol TEXT NOT NULL,
  timeframe TEXT NOT NULL,
  lookback_days INTEGER NOT NULL CHECK (lookback_days > 0),
  win_rate NUMERIC NOT NULL CHECK (win_rate >= 0 AND win_rate <= 1),
  sample_size INTEGER NOT NULL,
  params JSONB DEFAULT '{}'::JSONB,  -- {strategy_version: 'v1', min_score: 0.7, etc}
  computed_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(symbol, timeframe, lookback_days, COALESCE((params->>'strategy_version'), 'v1'))
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_win_rate_symbol_timeframe ON public.win_rate(symbol, timeframe);
CREATE INDEX IF NOT EXISTS idx_win_rate_computed_at ON public.win_rate(computed_at DESC);

-- ============================================================================
-- Message Queues (pgmq Extension)
-- ============================================================================

-- Enable pgmq extension
CREATE EXTENSION IF NOT EXISTS pgmq;

-- Create message queues
SELECT pgmq.create('ingest_indicators');
SELECT pgmq.create('compute_signals');
SELECT pgmq.create('compute_winrate');

-- Verify queues exist
-- SELECT * FROM pgmq.list_queues();

-- ============================================================================
-- Scheduled Jobs (pg_cron Extension)
-- ============================================================================

-- Enable pg_cron extension
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Schedule: Enqueue indicator ingestion every 5 minutes for active watchers
SELECT cron.schedule(
  'ingest_active_watchers',
  '*/5 * * * *',  -- Every 5 minutes
  $$
  SELECT pgmq.send(
    'ingest_indicators',
    jsonb_build_object(
      'symbol', symbol,
      'timeframe', timeframe,
      'user_id', user_id::TEXT
    )
  )
  FROM (
    SELECT DISTINCT symbol, timeframe, user_id
    FROM public.watchers
    WHERE active = TRUE
  ) AS active_watchers
  $$
);

-- Schedule: Recompute win rates every hour
SELECT cron.schedule(
  'recompute_winrate',
  '0 * * * *',  -- Every hour at :00
  $$
  SELECT pgmq.send(
    'compute_winrate',
    jsonb_build_object(
      'symbol', symbol,
      'timeframe', timeframe,
      'lookback_days', 30
    )
  )
  FROM (
    SELECT DISTINCT symbol, timeframe
    FROM public.watchers
    WHERE active = TRUE
  ) AS active_symbols
  $$
);

-- View scheduled jobs
-- SELECT * FROM cron.job;

-- ============================================================================
-- Utility Functions
-- ============================================================================

-- Function: Get latest signal for a symbol/timeframe
CREATE OR REPLACE FUNCTION public.get_latest_signal(
  p_symbol TEXT,
  p_timeframe TEXT DEFAULT '1h',
  p_user_id UUID DEFAULT NULL
)
RETURNS TABLE (
  signal_id BIGINT,
  direction TEXT,
  score NUMERIC,
  entry_price NUMERIC,
  stop_loss NUMERIC,
  take_profit NUMERIC[],
  confidence NUMERIC,
  reasons JSONB,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.id,
    s.direction,
    s.score,
    s.entry_price,
    s.stop_loss,
    s.take_profit,
    s.confidence,
    s.reasons,
    s.created_at
  FROM public.signals s
  WHERE s.symbol = p_symbol
    AND s.timeframe = p_timeframe
    AND (p_user_id IS NULL OR s.user_id = p_user_id OR s.user_id IS NULL)
  ORDER BY s.at DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql STABLE;

-- Function: Get latest indicators for a symbol/timeframe
CREATE OR REPLACE FUNCTION public.get_latest_indicators(
  p_symbol TEXT,
  p_timeframe TEXT DEFAULT '1h',
  p_source TEXT DEFAULT 'cryptometer'
)
RETURNS JSONB AS $$
  SELECT data
  FROM public.indicators
  WHERE symbol = p_symbol
    AND timeframe = p_timeframe
    AND source = p_source
  ORDER BY at DESC
  LIMIT 1;
$$ LANGUAGE sql STABLE;

-- Function: Get win rate for a symbol/timeframe
CREATE OR REPLACE FUNCTION public.get_win_rate(
  p_symbol TEXT,
  p_timeframe TEXT DEFAULT '1h',
  p_lookback_days INTEGER DEFAULT 30
)
RETURNS TABLE (
  win_rate NUMERIC,
  sample_size INTEGER,
  computed_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    wr.win_rate,
    wr.sample_size,
    wr.computed_at
  FROM public.win_rate wr
  WHERE wr.symbol = p_symbol
    AND wr.timeframe = p_timeframe
    AND wr.lookback_days = p_lookback_days
  ORDER BY wr.computed_at DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql STABLE;

-- ============================================================================
-- Data Retention / Cleanup Functions
-- ============================================================================

-- Function: Clean old indicators (keep last 90 days)
CREATE OR REPLACE FUNCTION public.cleanup_old_indicators()
RETURNS INTEGER AS $$
DECLARE
  v_deleted INTEGER;
BEGIN
  DELETE FROM public.indicators
  WHERE created_at < NOW() - INTERVAL '90 days';
  
  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN v_deleted;
END;
$$ LANGUAGE plpgsql;

-- Schedule: Run cleanup daily at 2 AM
SELECT cron.schedule(
  'cleanup_old_data',
  '0 2 * * *',  -- Daily at 2 AM
  $$SELECT public.cleanup_old_indicators()$$
);

-- ============================================================================
-- Sample Data (Optional - for testing)
-- ============================================================================

-- Uncomment to add sample data for development/testing
/*
-- Insert sample watchers
INSERT INTO public.watchers (user_id, symbol, timeframe, strategy)
VALUES
  ('00000000-0000-0000-0000-000000000001', 'BTC/USDT', '1h', '{"type": "momentum"}'::JSONB),
  ('00000000-0000-0000-0000-000000000001', 'ETH/USDT', '4h', '{"type": "trend_following"}'::JSONB)
ON CONFLICT (user_id, symbol, timeframe) DO NOTHING;

-- Insert sample indicators
INSERT INTO public.indicators (symbol, timeframe, data, source)
VALUES
  ('BTC/USDT', '1h', '{"rsi": 65, "macd": {"value": 150, "signal": 120}, "ema_20": 45000}'::JSONB, 'cryptometer'),
  ('ETH/USDT', '4h', '{"rsi": 58, "macd": {"value": -50, "signal": -30}, "ema_20": 3200}'::JSONB, 'cryptometer');

-- Insert sample signal
INSERT INTO public.signals (symbol, timeframe, direction, score, entry_price, stop_loss, take_profit, confidence, reasons)
VALUES
  ('BTC/USDT', '1h', 'long', 0.85, 45000, 44000, ARRAY[46000, 47000, 48000], 0.82, 
   '{"rsi_oversold": false, "macd_bullish": true, "ema_cross": true}'::JSONB);
*/

-- ============================================================================
-- Maintenance Queries
-- ============================================================================

-- Check table sizes
-- SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
-- FROM pg_tables WHERE schemaname = 'public';

-- View queue depths
-- SELECT 
--   'ingest_indicators' AS queue, COUNT(*) AS depth FROM pgmq.q_ingest_indicators
-- UNION ALL
-- SELECT 'compute_signals', COUNT(*) FROM pgmq.q_compute_signals
-- UNION ALL
-- SELECT 'compute_winrate', COUNT(*) FROM pgmq.q_compute_winrate;

-- View recent cron job runs
-- SELECT * FROM cron.job_run_details ORDER BY start_time DESC LIMIT 10;

-- View latest signals
-- SELECT symbol, timeframe, direction, score, confidence, created_at
-- FROM public.signals
-- ORDER BY created_at DESC
-- LIMIT 20;

-- ============================================================================
-- END OF SCHEMA
-- ============================================================================



