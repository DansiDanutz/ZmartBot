# MasterOrchestrationAgent - The Self-Learning Project Master

## Overview
The MasterOrchestrationAgent is the **intelligent master** of the entire ZmartBot project. It's a self-learning agent that understands, coordinates, and learns from the behavior of all other components. As the project grows, the agent becomes more intelligent through continuous learning and adaptation.

## Master Agent Architecture

### **Core Intelligence**
- **Self-Learning**: Continuously learns from system behavior
- **Adaptive**: Adjusts strategies based on performance data
- **Predictive**: Anticipates issues before they occur
- **Coordinated**: Manages all project components seamlessly

### **Knowledge Base**
- **Service Behavior Patterns**: Learns how each service operates
- **Port Management History**: Tracks port assignment patterns
- **Performance Metrics**: Monitors system efficiency
- **Failure Patterns**: Identifies and learns from issues

## What MasterOrchestrationAgent Does

### 1. **Core Service Management**
- **Backend API**: Monitors port 8000 performance and behavior
- **Frontend Dashboard**: Tracks port 3400 responsiveness and usage
- **Service Coordination**: Ensures all services work together optimally
- **Health Monitoring**: Continuous health checks and performance analysis

### 2. **STOP_ZMARTBOT Integration**
```python
def handle_stop_zmartbot_cycle():
    # Monitor for new service entries
    new_services = detect_new_service_entries()
    
    # Ensure new entries are added to Port Manager Database
    for service in new_services:
        port_manager.add_service_to_database(service)
    
    # Learn from the stop cycle
    learn_from_stop_cycle(new_services)
    
    # Update knowledge base
    update_service_behavior_patterns()
```

### 3. **Port Manager Database Integration**
- **New Entry Detection**: Identifies new services added during STOP cycle
- **Database Validation**: Ensures all entries are properly recorded
- **Pattern Recognition**: Learns from port assignment patterns
- **Conflict Prevention**: Uses learned patterns to prevent future conflicts

### 4. **START_ZMARTBOT System Integration**
```python
def integrate_new_services_to_startup():
    # Get new services from Port Manager Database
    new_services = port_manager.get_new_services()
    
    # Import them into START_ZMARTBOT system
    for service in new_services:
        startup_system.add_service(service)
    
    # Monitor their integration
    monitor_service_integration(new_services)
    
    # Learn from integration process
    learn_from_integration_patterns(new_services)
```

### 5. **Behavior Monitoring & Learning**
```python
def monitor_and_learn():
    # Monitor all service behaviors
    service_behaviors = monitor_all_services()
    
    # Analyze performance patterns
    performance_patterns = analyze_performance(service_behaviors)
    
    # Learn from successful patterns
    learn_from_success_patterns(performance_patterns)
    
    # Identify and learn from failures
    learn_from_failure_patterns(performance_patterns)
    
    # Update intelligence
    update_agent_intelligence()
```

## Self-Learning Capabilities

### **Service Behavior Learning**
- **Startup Patterns**: Learns optimal startup sequences
- **Port Usage Patterns**: Understands port assignment preferences
- **Performance Correlation**: Links service behavior to performance
- **Failure Prediction**: Anticipates issues based on patterns

### **Adaptive Decision Making**
```python
def adaptive_decision_making():
    # Analyze current system state
    current_state = analyze_system_state()
    
    # Make decisions based on learned patterns
    decisions = make_learned_decisions(current_state)
    
    # Execute decisions with monitoring
    execute_decisions_with_monitoring(decisions)
```

## @function: learn_active_profile

### Purpose
Learns and adapts to the currently active service profile.

### Implementation
```python
def learn_active_profile():
    """
    Learns the currently active service profile and adapts behavior accordingly.
    
    Returns:
        dict: Active profile information with learned patterns
    """
    # Load current profile
    profile = load_active_profile()
    
    # Analyze profile services
    service_analysis = {}
    for service_name in profile["services"]:
        # Learn service behavior patterns
        behavior_patterns = analyze_service_behavior(service_name)
        
        # Track performance metrics
        performance_metrics = get_service_performance(service_name)
        
        # Store learned patterns
        service_analysis[service_name] = {
            "behavior_patterns": behavior_patterns,
            "performance_metrics": performance_metrics,
            "optimal_configuration": learn_optimal_config(service_name)
        }
    
    # Update agent knowledge base
    update_profile_knowledge(profile["name"], service_analysis)
    
    return {
        "profile_name": profile["name"],
        "learned_services": service_analysis,
        "adaptation_strategy": generate_adaptation_strategy(service_analysis)
    }
```

## @function: stop_service

### Purpose
Intelligently stops a service with learned shutdown patterns.

### Implementation
```python
def stop_service(service_name: str, graceful: bool = True):
    """
    Stops a service using learned shutdown patterns.
    
    Args:
        service_name: Name of the service to stop
        graceful: Whether to attempt graceful shutdown first
    """
    # Get learned shutdown patterns for this service
    shutdown_patterns = get_learned_shutdown_patterns(service_name)
    
    if graceful and shutdown_patterns.get("graceful_shutdown"):
        # Attempt graceful shutdown
        try:
            graceful_stop_result = execute_graceful_shutdown(service_name)
            if graceful_stop_result.success:
                logger.info(f"Graceful shutdown successful for {service_name}")
                return
        except Exception as e:
            logger.warning(f"Graceful shutdown failed for {service_name}: {e}")
    
    # Fallback to force stop
    force_stop_result = execute_force_stop(service_name)
    
    # Learn from shutdown experience
    learn_from_shutdown_experience(service_name, graceful_stop_result, force_stop_result)
    
    logger.info(f"Service {service_name} stopped")
```

## @function: restart_service

### Purpose
Restarts a service using learned restart patterns and dependencies.

### Implementation
```python
def restart_service(service_name: str, reason: str = "manual"):
    """
    Restarts a service using learned restart patterns.
    
    Args:
        service_name: Name of the service to restart
        reason: Reason for restart (manual, failure, maintenance)
    """
    # Get service dependencies
    dependencies = get_service_dependencies(service_name)
    
    # Get learned restart patterns
    restart_patterns = get_learned_restart_patterns(service_name)
    
    # Stop service using learned patterns
    stop_service(service_name, graceful=True)
    
    # Wait for dependencies if needed
    if dependencies:
        wait_for_dependencies(dependencies)
    
    # Start service using learned patterns
    start_result = start_service_with_patterns(service_name, restart_patterns)
    
    # Learn from restart experience
    learn_from_restart_experience(service_name, start_result, reason)
    
    logger.info(f"Service {service_name} restarted successfully")
```

## @function: explain_topology

### Purpose
Explains the current system topology with learned insights.

### Implementation
```python
def explain_topology():
    """
    Explains the current system topology with learned insights.
    
    Returns:
        dict: Topology explanation with learned patterns
    """
    # Get current system state
    current_services = get_active_services()
    
    # Get learned topology patterns
    topology_patterns = get_learned_topology_patterns()
    
    # Analyze current topology
    topology_analysis = {
        "services": {},
        "connections": {},
        "performance_insights": {},
        "recommendations": []
    }
    
    for service in current_services:
        # Get service details
        service_details = get_service_details(service)
        
        # Get learned behavior patterns
        behavior_patterns = get_learned_behavior_patterns(service)
        
        # Analyze performance
        performance_analysis = analyze_service_performance(service)
        
        topology_analysis["services"][service] = {
            "details": service_details,
            "learned_patterns": behavior_patterns,
            "performance": performance_analysis,
            "recommendations": generate_service_recommendations(service)
        }
    
    # Generate overall topology insights
    topology_analysis["overall_insights"] = generate_topology_insights(topology_analysis)
    
    return topology_analysis

## @step: learn_active_profile

### Purpose
Learns the currently active profile from Service Registry and caches service information.

### Implementation
```python
def learn_active_profile():
    """
    Fetch active profile from Service Registry and cache service information.
    
    Returns:
        dict: Active profile with cached service information
    """
    import requests
    
    # Fetch current profile
    try:
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            services = active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            services = fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to fetch active profile: {e}")
        return {"services": [], "profile_name": "fallback"}
    
    # Cache service information
    cached_services = {}
    for service in services:
        service_name = service["service_name"]
        cached_services[service_name] = {
            "port": service.get("port"),
            "kind": service.get("kind"),
            "health_url": service.get("health_url"),
            "start_cmd": service.get("start_cmd"),
            "stop_cmd": service.get("stop_cmd"),
            "deps": service.get("deps", [])
        }
    
    return {
        "profile_name": data.get("profile_name", "default"),
        "services": cached_services,
        "service_order": [s["service_name"] for s in services]
    }
```

## @function: stop_service

### Purpose
Intelligently stops a service using learned stop patterns.

### Implementation
```python
def stop_service(name: str):
    """
    Stop a service using learned stop patterns.
    
    Args:
        name: Name of the service to stop
    """
    import subprocess
    import psutil
    
    # Get service information from cache
    profile = learn_active_profile()
    service_info = profile["services"].get(name)
    
    if not service_info:
        logger.error(f"Service {name} not found in active profile")
        return False
    
    stop_cmd = service_info.get("stop_cmd")
    
    if stop_cmd:
        try:
            logger.info(f"Stopping {name} with command: {stop_cmd}")
            subprocess.run(stop_cmd.split(), check=True)
            logger.info(f"✅ {name} stopped successfully")
            return True
        except subprocess.CalledProcessError as e:
            logger.warning(f"Stop command failed for {name}: {e}")
    
    # Fallback: find and kill process by port
    port = service_info.get("port")
    if port:
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    process = psutil.Process(conn.pid)
                    process.terminate()
                    logger.info(f"✅ {name} stopped via PID {conn.pid}")
                    return True
        except Exception as e:
            logger.error(f"Failed to stop {name} via PID: {e}")
    
    # Final fallback: use ProcessReaper
    try:
        from src.utils.doctor_kill import DoctorKill
        doctor = DoctorKill()
        doctor.kill_processes_by_name(name)
        logger.info(f"✅ {name} stopped via ProcessReaper")
        return True
    except Exception as e:
        logger.error(f"Failed to stop {name} via ProcessReaper: {e}")
        return False
```

## @function: restart_service

### Purpose
Restarts a service using learned restart patterns and dependencies.

### Implementation
```python
def restart_service(name: str):
    """
    Restart a service using learned restart patterns.
    
    Args:
        name: Name of the service to restart
    """
    import subprocess
    import time
    
    # Get service information from cache
    profile = learn_active_profile()
    service_info = profile["services"].get(name)
    
    if not service_info:
        logger.error(f"Service {name} not found in active profile")
        return False
    
    # Stop service first
    logger.info(f"Restarting {name}...")
    stop_service(name)
    
    # Wait for service to stop
    time.sleep(1)
    
    # Start service
    start_cmd = service_info.get("start_cmd")
    if start_cmd:
        try:
            logger.info(f"Starting {name} with command: {start_cmd}")
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            health_url = service_info.get("health_url")
            if health_url:
                import requests
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"✅ {name} restarted successfully")
                        return True
                    else:
                        logger.warning(f"⚠️ {name} restarted but health check failed")
                        return False
                except Exception as e:
                    logger.warning(f"⚠️ {name} restarted but health check failed: {e}")
                    return False
            else:
                logger.info(f"✅ {name} restarted (no health URL)")
                return True
                
        except Exception as e:
            logger.error(f"❌ Failed to restart {name}: {e}")
            return False
    else:
        logger.error(f"No start command found for {name}")
        return False
```

## @function: explain_topology

### Purpose
Explains the current system topology with learned insights.

### Implementation
```python
def explain_topology():
    """
    Print service → deps → port → health_url mapping.
    
    Returns:
        dict: Topology explanation
    """
    # Get active profile
    profile = learn_active_profile()
    services = profile["services"]
    
    print("\n🌐 SYSTEM TOPOLOGY")
    print("=" * 60)
    print("Service → Dependencies → Port → Health URL")
    print("-" * 60)
    
    topology = {}
    
    for service_name, service_info in services.items():
        port = service_info.get("port", "N/A")
        deps = service_info.get("deps", [])
        health_url = service_info.get("health_url", "N/A")
        
        deps_str = ", ".join(deps) if deps else "none"
        
        print(f"{service_name:<15} → {deps_str:<20} → {port:<6} → {health_url}")
        
        topology[service_name] = {
            "port": port,
            "dependencies": deps,
            "health_url": health_url,
            "kind": service_info.get("kind")
        }
    
    print("=" * 60)
    
    # Print dependency graph
    print("\n📊 DEPENDENCY GRAPH:")
    for service_name, info in topology.items():
        if info["dependencies"]:
            print(f"  {service_name} depends on: {', '.join(info['dependencies'])}")
        else:
            print(f"  {service_name} (no dependencies)")
    
    return topology
```
    
    # Apply learned patterns
    learned_patterns = get_learned_patterns()
    
    # Make intelligent decisions
    decisions = apply_intelligence(current_state, learned_patterns)
    
    # Execute decisions
    execute_decisions(decisions)
    
    # Learn from outcomes
    learn_from_outcomes(decisions, outcomes)
```

### **Intelligence Growth**
- **Pattern Recognition**: Identifies recurring system behaviors
- **Predictive Analysis**: Forecasts potential issues
- **Optimization Learning**: Finds better ways to coordinate services
- **Adaptive Strategies**: Adjusts approaches based on results

## ProcessReaper Integration

### **Collaborative Problem Solving**
```python
def collaborate_with_processreaper():
# ProcessReaper provides diagnosis
diagnosis = processreaper.diagnose_system()
    
    # Master Agent analyzes diagnosis
    analysis = analyze_doctorkill_diagnosis(diagnosis)
    
    # Apply learned solutions
    solutions = apply_learned_solutions(analysis)
    
    # Coordinate with ProcessReaper for resolution
resolution = coordinate_resolution(processreaper, solutions)
    
    # Learn from the resolution process
    learn_from_resolution_process(resolution)
```

### **Enhanced Intelligence**
- **Problem Pattern Recognition**: Learns from ProcessReaper diagnoses
- **Solution Effectiveness**: Tracks which solutions work best
- **Preventive Measures**: Implements learned preventive strategies
- **Collaborative Learning**: Grows intelligence through collaboration

## Knowledge Base Structure

### **Service Behavior Database**
```sql
CREATE TABLE service_behavior_patterns (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    behavior_type TEXT NOT NULL,
    pattern_data JSON,
    success_rate FLOAT,
    learned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    applied_count INTEGER DEFAULT 0
);
```

### **Performance Learning Database**
```sql
CREATE TABLE performance_learning (
    id INTEGER PRIMARY KEY,
    scenario TEXT NOT NULL,
    action_taken TEXT NOT NULL,
    outcome TEXT NOT NULL,
    performance_metric FLOAT,
    learned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **Intelligence Growth Tracking**
```sql
CREATE TABLE intelligence_growth (
    id INTEGER PRIMARY KEY,
    learning_event TEXT NOT NULL,
    intelligence_gain FLOAT,
    pattern_recognized TEXT,
    applied_successfully BOOLEAN,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## Learning Algorithms

### **Pattern Recognition**
```python
def recognize_patterns(service_data):
    # Analyze service behavior data
    patterns = analyze_service_data(service_data)
    
    # Identify recurring patterns
    recurring_patterns = find_recurring_patterns(patterns)
    
    # Calculate pattern reliability
    reliability = calculate_pattern_reliability(recurring_patterns)
    
    # Store learned patterns
    store_learned_patterns(recurring_patterns, reliability)
```

### **Predictive Analysis**
```python
def predictive_analysis():
    # Get historical data
    historical_data = get_historical_performance_data()
    
    # Apply machine learning models
    predictions = apply_ml_models(historical_data)
    
    # Generate proactive recommendations
    recommendations = generate_recommendations(predictions)
    
    # Implement preventive measures
    implement_preventive_measures(recommendations)
```

### **Adaptive Optimization**
```python
def adaptive_optimization():
    # Monitor current performance
    current_performance = monitor_current_performance()
    
    # Compare with learned optimal states
    optimal_states = get_learned_optimal_states()
    
    # Identify optimization opportunities
    opportunities = identify_optimization_opportunities(
        current_performance, optimal_states
    )
    
    # Apply optimizations
    apply_optimizations(opportunities)
    
    # Learn from optimization results
    learn_from_optimization_results(opportunities, results)
```

## Intelligence Growth Metrics

### **Learning Progress Tracking**
- **Pattern Recognition Rate**: How quickly new patterns are identified
- **Prediction Accuracy**: Success rate of predictive analysis
- **Problem Resolution Speed**: Time to resolve issues using learned patterns
- **System Optimization Effectiveness**: Performance improvements from learned strategies

### **Intelligence Indicators**
- **Service Coordination Efficiency**: How well services work together
- **Port Management Optimization**: Reduction in port conflicts
- **Startup Time Improvement**: Faster system startup through learned patterns
- **Error Rate Reduction**: Fewer errors through predictive prevention

## Integration with All Components

### **With START_ZMARTBOT**
- **Intelligent Startup**: Uses learned patterns for optimal startup
- **Service Coordination**: Ensures services start in optimal order
- **Performance Monitoring**: Tracks startup performance for learning
- **Adaptive Adjustments**: Makes real-time adjustments based on learned patterns

### **With STOP_ZMARTBOT**
- **Intelligent Shutdown**: Uses learned patterns for clean shutdown
- **Data Preservation**: Ensures all learning data is preserved
- **Pattern Analysis**: Analyzes shutdown patterns for learning
- **Preparation for Next Cycle**: Prepares for optimal next startup

### **With PortManager**
- **Intelligent Port Assignment**: Uses learned patterns for port assignments
- **Conflict Prevention**: Prevents conflicts based on learned patterns
- **Service Optimization**: Optimizes service placement based on learned behavior
- **Performance Correlation**: Links port assignments to performance outcomes

### **With OrchestrationStart**
- **Intelligent Orchestration**: Uses learned patterns for service orchestration
- **Adaptive Coordination**: Adjusts coordination based on learned behavior
- **Performance Optimization**: Optimizes orchestration for better performance
- **Learning Integration**: Integrates new learning into orchestration strategies

## Success Criteria

### **Intelligence Growth**
- ✅ Pattern recognition accuracy > 90%
- ✅ Predictive analysis success rate > 85%
- ✅ Problem resolution time reduced by 50%
- ✅ System performance improved by 30%

### **Coordination Effectiveness**
- ✅ All services coordinated optimally
- ✅ Port conflicts reduced to < 1%
- ✅ Startup time optimized
- ✅ System stability improved

### **Learning Integration**
- ✅ New patterns learned and applied
- ✅ Intelligence continuously growing
- ✅ Collaborative learning with ProcessReaper
- ✅ Adaptive strategies implemented

## Future Intelligence Capabilities

### **Advanced Learning**
- **Deep Learning Integration**: Neural networks for complex pattern recognition
- **Natural Language Processing**: Understanding system logs and reports
- **Predictive Maintenance**: Anticipating system maintenance needs
- **Autonomous Optimization**: Self-optimizing system configurations

### **Collaborative Intelligence**
- **Multi-Agent Learning**: Learning from other AI agents
- **Cross-System Learning**: Learning from similar systems
- **Community Intelligence**: Sharing and learning from community knowledge
- **Continuous Evolution**: Never-ending intelligence growth

The MasterOrchestrationAgent is the intelligent heart of the ZmartBot system, continuously learning, adapting, and growing more intelligent as the project evolves. It coordinates all components while building a comprehensive understanding of system behavior, making the entire project more efficient, stable, and intelligent over time.

## @step: learn_active_profile
- Fetch http://127.0.0.1:8610/profiles/current
- If not set → use /profiles/default + /services/active
- Cache: services (order), kind, port, health_url, deps, start_cmd, stop_cmd

## @function: stop_service(name)
- Run `stop_cmd` for name; if PID persists → ProcessReaper

## @function: restart_service(name)
- stop_service(name) → start via `start_cmd`

## @function: explain_topology()
- Print service → deps → port → health_url map

@function: manage_state_snapshots()
- Handle state screenshot creation during STOP operations
- Manage cached data serving during START operations
- Coordinate transition from cached to live data
- Clear cached data after successful live data transition

@function: integrate_new_services()
- Receive notifications from Service Discovery Agent
- Update service cache with new service information
- Update dependency maps and topology
- Add new services to health monitoring
- Include new services in orchestration management
description:
globs:
alwaysApply: false
---
