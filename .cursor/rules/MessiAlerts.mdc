@trigger: event_detection_engine

# Messi Alerts - High-Frequency Trading Pattern System

## Overview
**Messi Alerts** represent the **high-frequency trading patterns** in the ZmartBot system, named after the legendary footballer's quick, agile movements. These alerts detect rapid market oscillations, micro-volume spikes, and momentum shifts that create scalping and high-frequency trading opportunities.

## Messi Alert Philosophy

### **Core Concept**
Messi Alerts are designed to capture **micro-movements** and **rapid market changes** that occur within short timeframes. Just as Messi's playing style was characterized by quick direction changes, rapid acceleration, and precise micro-movements, these alerts identify similar patterns in market behavior.

### **Trading Style**
- **Timeframe Focus**: Primarily 15m and 1h charts
- **Trading Approach**: Scalping and high-frequency trading
- **Position Duration**: Minutes to hours (not days)
- **Risk Management**: Tight stop-losses, quick profit-taking

## Alert Trigger Mechanisms

### **1. Messi RSI Oscillation Pattern**

#### **Trigger Detection Algorithm**
```python
class MessiRSIOscillation:
    def __init__(self):
        self.rsi_history = []
        self.oscillation_threshold = 5  # RSI points
        self.time_window = 10  # candles to analyze
        
    def detect_rsi_oscillations(self, current_rsi, symbol, timeframe):
        """Detect rapid RSI oscillations within short time window"""
        
        # Add current RSI to history
        self.rsi_history.append({
            'value': current_rsi,
            'timestamp': datetime.now(),
            'symbol': symbol,
            'timeframe': timeframe
        })
        
        # Keep only recent history
        if len(self.rsi_history) > self.time_window:
            self.rsi_history.pop(0)
        
        # Calculate oscillation metrics
        if len(self.rsi_history) >= 5:
            oscillations = self.calculate_oscillations()
            
            # Check for rapid oscillations
            if oscillations['count'] >= 3 and oscillations['amplitude'] >= self.oscillation_threshold:
                return self.create_messi_rsi_alert(oscillations)
        
        return None
    
    def calculate_oscillations(self):
        """Calculate oscillation patterns in RSI"""
        values = [entry['value'] for entry in self.rsi_history]
        
        oscillations = {
            'count': 0,
            'amplitude': 0,
            'direction_changes': 0,
            'avg_speed': 0
        }
        
        # Count direction changes
        for i in range(1, len(values) - 1):
            if (values[i] > values[i-1] and values[i] > values[i+1]) or \
               (values[i] < values[i-1] and values[i] < values[i+1]):
                oscillations['count'] += 1
        
        # Calculate amplitude
        oscillations['amplitude'] = max(values) - min(values)
        
        # Calculate average speed of change
        speed_changes = []
        for i in range(1, len(values)):
            speed_changes.append(abs(values[i] - values[i-1]))
        oscillations['avg_speed'] = sum(speed_changes) / len(speed_changes)
        
        return oscillations
```

#### **What Happens When Triggered**
```python
def create_messi_rsi_alert(self, oscillations):
    """Create Messi RSI alert when oscillations detected"""
    
    alert = AlertTrigger(
        type="MESSI_RSI_OSCILLATION",
        symbol=self.rsi_history[-1]['symbol'],
        timeframe=self.rsi_history[-1]['timeframe'],
        value=self.rsi_history[-1]['value'],
        message=f"Messi RSI Pattern: {oscillations['count']} oscillations detected with {oscillations['amplitude']:.1f} amplitude",
        severity="HIGH",
        action="High-frequency trading opportunity - prepare for quick reversals",
        indicators_triggered=["RSI", "Stochastic Oscillator", "Williams %R"],
        oscillation_data=oscillations,
        trading_opportunity={
            'type': 'scalping',
            'entry_strategy': 'momentum_following',
            'exit_strategy': 'quick_profit',
            'stop_loss': 'tight',
            'target_timeframe': '5-15_minutes'
        }
    )
    
    return alert
```

### **2. Messi Volume Spike Pattern**

#### **Trigger Detection Algorithm**
```python
class MessiVolumeSpike:
    def __init__(self):
        self.volume_history = []
        self.micro_threshold = 1.5  # 150% of average
        self.macro_threshold = 3.0   # 300% of average
        self.time_window = 20  # candles to analyze
        
    def detect_micro_volume_spikes(self, current_volume, symbol, timeframe):
        """Detect micro-volume spikes that indicate high-frequency activity"""
        
        # Add current volume to history
        self.volume_history.append({
            'volume': current_volume,
            'timestamp': datetime.now(),
            'symbol': symbol,
            'timeframe': timeframe
        })
        
        # Keep only recent history
        if len(self.volume_history) > self.time_window:
            self.volume_history.pop(0)
        
        # Calculate volume metrics
        if len(self.volume_history) >= 10:
            volume_analysis = self.analyze_volume_patterns()
            
            # Check for micro-volume spikes
            if volume_analysis['micro_spikes'] >= 2 and volume_analysis['avg_ratio'] >= self.micro_threshold:
                return self.create_messi_volume_alert(volume_analysis)
        
        return None
    
    def analyze_volume_patterns(self):
        """Analyze volume patterns for micro-spikes"""
        volumes = [entry['volume'] for entry in self.volume_history]
        avg_volume = sum(volumes) / len(volumes)
        
        analysis = {
            'micro_spikes': 0,
            'macro_spikes': 0,
            'avg_ratio': 0,
            'spike_frequency': 0,
            'volume_trend': 'stable'
        }
        
        # Count spikes
        for volume in volumes:
            ratio = volume / avg_volume
            if ratio >= self.micro_threshold:
                analysis['micro_spikes'] += 1
            if ratio >= self.macro_threshold:
                analysis['macro_spikes'] += 1
        
        analysis['avg_ratio'] = sum([v/avg_volume for v in volumes]) / len(volumes)
        analysis['spike_frequency'] = analysis['micro_spikes'] / len(volumes)
        
        return analysis
```

#### **What Happens When Triggered**
```python
def create_messi_volume_alert(self, volume_analysis):
    """Create Messi Volume alert when micro-spikes detected"""
    
    alert = AlertTrigger(
        type="MESSI_VOLUME_SPIKE",
        symbol=self.volume_history[-1]['symbol'],
        timeframe=self.volume_history[-1]['timeframe'],
        value=self.volume_history[-1]['volume'],
        message=f"Messi Volume Pattern: {volume_analysis['micro_spikes']} micro-spikes detected with {volume_analysis['avg_ratio']:.1f}x average volume",
        severity="MEDIUM",
        action="Scalping opportunity - prepare for quick entries/exits",
        indicators_triggered=["Volume Analysis", "OBV", "MFI"],
        volume_data=volume_analysis,
        trading_opportunity={
            'type': 'volume_scalping',
            'entry_strategy': 'volume_confirmation',
            'exit_strategy': 'volume_depletion',
            'stop_loss': 'volume_based',
            'target_timeframe': '1-5_minutes'
        }
    )
    
    return alert
```

### **3. Messi Momentum Shift Pattern**

#### **Trigger Detection Algorithm**
```python
class MessiMomentumShift:
    def __init__(self):
        self.momentum_history = []
        self.shift_threshold = 0.02  # 2% momentum change
        self.acceleration_threshold = 0.01  # 1% acceleration
        self.time_window = 15  # candles to analyze
        
    def detect_momentum_shifts(self, current_momentum, symbol, timeframe):
        """Detect rapid momentum shifts and accelerations"""
        
        # Add current momentum to history
        self.momentum_history.append({
            'momentum': current_momentum,
            'timestamp': datetime.now(),
            'symbol': symbol,
            'timeframe': timeframe
        })
        
        # Keep only recent history
        if len(self.momentum_history) > self.time_window:
            self.momentum_history.pop(0)
        
        # Calculate momentum metrics
        if len(self.momentum_history) >= 8:
            momentum_analysis = self.analyze_momentum_patterns()
            
            # Check for rapid momentum shifts
            if momentum_analysis['shifts'] >= 2 and momentum_analysis['acceleration'] >= self.acceleration_threshold:
                return self.create_messi_momentum_alert(momentum_analysis)
        
        return None
    
    def analyze_momentum_patterns(self):
        """Analyze momentum patterns for rapid shifts"""
        momentums = [entry['momentum'] for entry in self.momentum_history]
        
        analysis = {
            'shifts': 0,
            'acceleration': 0,
            'direction_changes': 0,
            'momentum_strength': 0,
            'volatility': 0
        }
        
        # Count momentum shifts
        for i in range(1, len(momentums)):
            change = abs(momentums[i] - momentums[i-1])
            if change >= self.shift_threshold:
                analysis['shifts'] += 1
        
        # Calculate acceleration
        if len(momentums) >= 3:
            acceleration_changes = []
            for i in range(2, len(momentums)):
                accel = abs(momentums[i] - 2*momentums[i-1] + momentums[i-2])
                acceleration_changes.append(accel)
            analysis['acceleration'] = sum(acceleration_changes) / len(acceleration_changes)
        
        # Calculate volatility
        analysis['volatility'] = statistics.stdev(momentums) if len(momentums) > 1 else 0
        
        return analysis
```

#### **What Happens When Triggered**
```python
def create_messi_momentum_alert(self, momentum_analysis):
    """Create Messi Momentum alert when rapid shifts detected"""
    
    alert = AlertTrigger(
        type="MESSI_MOMENTUM_SHIFT",
        symbol=self.momentum_history[-1]['symbol'],
        timeframe=self.momentum_history[-1]['timeframe'],
        value=self.momentum_history[-1]['momentum'],
        message=f"Messi Momentum Pattern: {momentum_analysis['shifts']} rapid shifts detected with {momentum_analysis['acceleration']:.3f} acceleration",
        severity="HIGH",
        action="High-frequency momentum trading - adapt quickly",
        indicators_triggered=["Momentum Indicator", "ROC", "TRIX"],
        momentum_data=momentum_analysis,
        trading_opportunity={
            'type': 'momentum_scalping',
            'entry_strategy': 'momentum_breakout',
            'exit_strategy': 'momentum_reversal',
            'stop_loss': 'momentum_based',
            'target_timeframe': '5-30_minutes'
        }
    )
    
    return alert
```

## Dynamic Indicator Changes

### **Real-Time Indicator Updates**

#### **1. RSI Dynamic Changes**
```javascript
class MessiRSIDynamicUpdater {
    constructor() {
        this.updateFrequency = 5000; // 5 seconds
        this.oscillationBuffer = [];
    }
    
    updateRSIOnMessiAlert(alert) {
        const rsiCard = document.getElementById(`rsi-card-${alert.symbol}`);
        const rsiChart = rsiCard.querySelector('.rsi-chart');
        const rsiValue = rsiCard.querySelector('.rsi-value');
        
        // Add oscillation data to buffer
        this.oscillationBuffer.push(alert.oscillation_data);
        
        // Update RSI display with oscillation indicators
        this.addOscillationIndicators(rsiChart, alert.oscillation_data);
        
        // Update value with oscillation highlighting
        rsiValue.textContent = alert.value;
        rsiValue.classList.add('messi-oscillation');
        
        // Add oscillation frequency indicator
        this.addOscillationFrequency(rsiCard, alert.oscillation_data);
        
        // Start real-time updates
        this.startRealTimeUpdates(alert.symbol);
    }
    
    addOscillationIndicators(chart, oscillationData) {
        // Add oscillation bands to chart
        const oscillationBand = document.createElement('div');
        oscillationBand.className = 'oscillation-band';
        oscillationBand.style.height = `${oscillationData.amplitude}%`;
        oscillationBand.style.backgroundColor = 'rgba(255, 215, 0, 0.3)'; // Gold color
        
        chart.appendChild(oscillationBand);
        
        // Add oscillation markers
        oscillationData.peak_points.forEach(point => {
            const marker = document.createElement('div');
            marker.className = 'oscillation-marker';
            marker.style.left = `${point.position}%`;
            marker.style.top = `${point.value}%`;
            chart.appendChild(marker);
        });
    }
    
    addOscillationFrequency(card, oscillationData) {
        const frequencyIndicator = document.createElement('div');
        frequencyIndicator.className = 'oscillation-frequency';
        frequencyIndicator.innerHTML = `
            <span class="frequency-label">Oscillation Frequency:</span>
            <span class="frequency-value">${oscillationData.count} in ${oscillationData.time_window} periods</span>
            <span class="frequency-speed">Speed: ${oscillationData.avg_speed.toFixed(2)}/period</span>
        `;
        
        card.appendChild(frequencyIndicator);
    }
    
    startRealTimeUpdates(symbol) {
        setInterval(() => {
            this.updateOscillationMetrics(symbol);
        }, this.updateFrequency);
    }
    
    updateOscillationMetrics(symbol) {
        // Update oscillation metrics in real-time
        const rsiCard = document.getElementById(`rsi-card-${symbol}`);
        const frequencyValue = rsiCard.querySelector('.frequency-value');
        const speedValue = rsiCard.querySelector('.frequency-speed');
        
        // Calculate new metrics from buffer
        const recentOscillations = this.oscillationBuffer.slice(-5);
        const avgCount = recentOscillations.reduce((sum, osc) => sum + osc.count, 0) / recentOscillations.length;
        const avgSpeed = recentOscillations.reduce((sum, osc) => sum + osc.avg_speed, 0) / recentOscillations.length;
        
        frequencyValue.textContent = `${avgCount.toFixed(1)} avg oscillations`;
        speedValue.textContent = `Speed: ${avgSpeed.toFixed(2)}/period`;
    }
}
```

#### **2. Volume Dynamic Changes**
```javascript
class MessiVolumeDynamicUpdater {
    constructor() {
        this.updateFrequency = 3000; // 3 seconds
        this.volumeBuffer = [];
    }
    
    updateVolumeOnMessiAlert(alert) {
        const volumeCard = document.getElementById(`volume-card-${alert.symbol}`);
        const volumeChart = volumeCard.querySelector('.volume-chart');
        const volumeValue = volumeCard.querySelector('.volume-value');
        
        // Add volume data to buffer
        this.volumeBuffer.push(alert.volume_data);
        
        // Update volume display with micro-spike indicators
        this.addMicroSpikeIndicators(volumeChart, alert.volume_data);
        
        // Update value with spike highlighting
        volumeValue.textContent = `${alert.value.toLocaleString()}`;
        volumeValue.classList.add('messi-spike');
        
        // Add spike frequency indicator
        this.addSpikeFrequency(volumeCard, alert.volume_data);
        
        // Start real-time updates
        this.startRealTimeUpdates(alert.symbol);
    }
    
    addMicroSpikeIndicators(chart, volumeData) {
        // Add micro-spike markers to chart
        volumeData.spike_points.forEach(spike => {
            const spikeMarker = document.createElement('div');
            spikeMarker.className = 'micro-spike-marker';
            spikeMarker.style.left = `${spike.position}%`;
            spikeMarker.style.height = `${spike.intensity}%`;
            spikeMarker.style.backgroundColor = spike.intensity > 2.0 ? '#ff6b6b' : '#ffd93d';
            
            chart.appendChild(spikeMarker);
        });
        
        // Add volume trend line
        this.addVolumeTrendLine(chart, volumeData);
    }
    
    addVolumeTrendLine(chart, volumeData) {
        const trendLine = document.createElement('div');
        trendLine.className = 'volume-trend-line';
        trendLine.style.background = `linear-gradient(90deg, 
            ${volumeData.trend === 'increasing' ? '#4CAF50' : '#f44336'} 0%, 
            ${volumeData.trend === 'increasing' ? '#81C784' : '#e57373'} 100%)`;
        
        chart.appendChild(trendLine);
    }
    
    addSpikeFrequency(card, volumeData) {
        const frequencyIndicator = document.createElement('div');
        frequencyIndicator.className = 'spike-frequency';
        frequencyIndicator.innerHTML = `
            <span class="spike-label">Micro-Spike Frequency:</span>
            <span class="spike-value">${volumeData.micro_spikes} spikes</span>
            <span class="spike-ratio">Ratio: ${volumeData.avg_ratio.toFixed(1)}x avg</span>
        `;
        
        card.appendChild(frequencyIndicator);
    }
}
```

#### **3. Momentum Dynamic Changes**
```javascript
class MessiMomentumDynamicUpdater {
    constructor() {
        this.updateFrequency = 2000; // 2 seconds
        this.momentumBuffer = [];
    }
    
    updateMomentumOnMessiAlert(alert) {
        const momentumCard = document.getElementById(`momentum-card-${alert.symbol}`);
        const momentumChart = momentumCard.querySelector('.momentum-chart');
        const momentumValue = momentumCard.querySelector('.momentum-value');
        
        // Add momentum data to buffer
        this.momentumBuffer.push(alert.momentum_data);
        
        // Update momentum display with shift indicators
        this.addMomentumShiftIndicators(momentumChart, alert.momentum_data);
        
        // Update value with shift highlighting
        momentumValue.textContent = `${alert.value.toFixed(3)}`;
        momentumValue.classList.add('messi-shift');
        
        // Add shift frequency indicator
        this.addShiftFrequency(momentumCard, alert.momentum_data);
        
        // Start real-time updates
        this.startRealTimeUpdates(alert.symbol);
    }
    
    addMomentumShiftIndicators(chart, momentumData) {
        // Add momentum shift markers
        momentumData.shift_points.forEach(shift => {
            const shiftMarker = document.createElement('div');
            shiftMarker.className = 'momentum-shift-marker';
            shiftMarker.style.left = `${shift.position}%`;
            shiftMarker.style.top = `${shift.value}%`;
            shiftMarker.style.backgroundColor = shift.direction === 'up' ? '#4CAF50' : '#f44336';
            
            chart.appendChild(shiftMarker);
        });
        
        // Add acceleration curve
        this.addAccelerationCurve(chart, momentumData);
    }
    
    addAccelerationCurve(chart, momentumData) {
        const accelerationCurve = document.createElement('div');
        accelerationCurve.className = 'acceleration-curve';
        accelerationCurve.style.background = `linear-gradient(45deg, 
            ${momentumData.acceleration > 0.02 ? '#ff9800' : '#2196F3'} 0%, 
            ${momentumData.acceleration > 0.02 ? '#ff5722' : '#03A9F4'} 100%)`;
        
        chart.appendChild(accelerationCurve);
    }
    
    addShiftFrequency(card, momentumData) {
        const frequencyIndicator = document.createElement('div');
        frequencyIndicator.className = 'shift-frequency';
        frequencyIndicator.innerHTML = `
            <span class="shift-label">Momentum Shifts:</span>
            <span class="shift-value">${momentumData.shifts} shifts</span>
            <span class="shift-acceleration">Accel: ${momentumData.acceleration.toFixed(3)}</span>
        `;
        
        card.appendChild(frequencyIndicator);
    }
}
```

## Trading Integration

### **Messi Alert Trading Strategy**
```python
class MessiTradingStrategy:
    def __init__(self):
        self.active_positions = {}
        self.messi_alerts = []
        self.risk_manager = MessiRiskManager()
    
    def process_messi_alert(self, alert):
        """Process Messi alert and execute trading strategy"""
        
        # Check if we should enter a position
        if self.should_enter_position(alert):
            position = self.enter_position(alert)
            self.active_positions[alert.symbol] = position
        
        # Check if we should exit existing position
        elif alert.symbol in self.active_positions:
            if self.should_exit_position(alert):
                self.exit_position(alert.symbol)
    
    def should_enter_position(self, alert):
        """Determine if we should enter a position based on Messi alert"""
        
        # Check risk management rules
        if not self.risk_manager.can_enter_position(alert.symbol):
            return False
        
        # Check alert strength
        if alert.severity != "HIGH":
            return False
        
        # Check for confirmation from multiple indicators
        confirmed_indicators = self.get_confirmed_indicators(alert)
        if len(confirmed_indicators) < 2:
            return False
        
        return True
    
    def enter_position(self, alert):
        """Enter a position based on Messi alert"""
        
        position = {
            'symbol': alert.symbol,
            'entry_price': self.get_current_price(alert.symbol),
            'entry_time': datetime.now(),
            'alert_type': alert.type,
            'direction': self.determine_direction(alert),
            'size': self.calculate_position_size(alert),
            'stop_loss': self.calculate_stop_loss(alert),
            'take_profit': self.calculate_take_profit(alert),
            'timeframe': alert.timeframe
        }
        
        # Execute trade
        self.execute_trade(position)
        
        return position
    
    def determine_direction(self, alert):
        """Determine trade direction based on Messi alert type"""
        
        if alert.type == "MESSI_RSI_OSCILLATION":
            # Trade in direction of recent oscillation
            return "LONG" if alert.value > 50 else "SHORT"
        
        elif alert.type == "MESSI_VOLUME_SPIKE":
            # Trade with volume direction
            return "LONG" if alert.volume_data.trend == "increasing" else "SHORT"
        
        elif alert.type == "MESSI_MOMENTUM_SHIFT":
            # Trade with momentum direction
            return "LONG" if alert.momentum_data.direction == "up" else "SHORT"
        
        return "NEUTRAL"
```

## Success Criteria

### **Messi Alert Performance**
- ✅ **Real-time detection** of rapid oscillations within 5 seconds
- ✅ **Accurate micro-pattern recognition** with 85%+ accuracy
- ✅ **Dynamic indicator updates** that reflect current market conditions
- ✅ **Scalping opportunity identification** with clear entry/exit signals

### **Trading Integration**
- ✅ **Automated position management** based on Messi alerts
- ✅ **Risk management integration** with tight stop-losses
- ✅ **Multi-indicator confirmation** for entry decisions
- ✅ **Quick profit-taking** based on pattern completion

### **User Experience**
- ✅ **Visual oscillation indicators** on RSI charts
- ✅ **Micro-spike markers** on volume charts
- ✅ **Momentum shift indicators** with acceleration curves
- ✅ **Real-time frequency updates** showing pattern intensity

The Messi Alerts system provides **high-frequency trading opportunities** through rapid pattern recognition, dynamic indicator updates, and automated trading integration that captures micro-movements in the market for scalping and quick profit-taking strategies.
description:
globs:
alwaysApply: true
---