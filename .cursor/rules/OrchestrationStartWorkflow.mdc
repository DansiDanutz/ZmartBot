# Orchestrationstartworkflow - Merged MDC Configuration


## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-09-01 00:11:21
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-31 20:10:54
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-31 14:25:51
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-31 09:30:55
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-31 03:55:38
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-30 15:34:11
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-30 11:32:15
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-30 07:23:02
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-30 11:06:01
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-29 22:55:51
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-29 17:58:21
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-29 11:57:30
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-29 07:28:17
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-27 10:39:58
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# Orchestrationstartworkflow - Merged MDC Configuration

## üîó Merged from 2 duplicate files
**Merged Files**: OrchestrationStartWorkflow.mdc, OrchestrationStart.mdc
**Merge Date**: 2025-08-26 09:03:52
**Primary Source**: OrchestrationStartWorkflow.mdc

## üìã Primary Configuration
# OrchestrationStart Workflow - Quick Reference
> Purpose: Quick reference for integrating new services into the orchestration system

## Overview
When adding a new service to ZmartBot, it MUST be integrated into the orchestration system to ensure it starts automatically with the system.

## Required Steps for New Service Integration

### Step 1: Service Registration
```bash
# Register service in port registry
sqlite3 zmart-api/port_registry.db "INSERT INTO port_assignments (service_name, port, service_type, status, pid, assigned_at, updated_at, description) VALUES ('new-service-name', PORT, 'service_type', 'registered', NULL, datetime('now'), datetime('now'), 'Service description');"
```

### Step 2: Update OrchestrationStart Script
Add the new service to `zmart-api/infra/orchestration/orchestrationstart.sh`:

1. **Add to SERVICE_STARTUP_ORDER array** (in dependency order)
2. **Add to get_service_dir() function** (directory mapping)
3. **Add to get_service_command() function** (startup command)

### Step 3: Orchestration Integration
```bash
# Add service to orchestration
cd zmart-api/infra/orchestration
./orchestrationstart.sh add "new-service-name"

# Test service startup
./orchestrationstart.sh start "new-service-name"

# Verify health
./orchestrationstart.sh health "new-service-name"

# Check status
./orchestrationstart.sh status
```

### Step 4: Update Master Orchestration Agent
Update `.cursor/rules/MasterOrchestrationAgent.mdc`:
- Add service to "Currently Registered Services" list
- Add to appropriate service category
- Update dependency mapping
- Add to changelog

## Service Name Mapping Rules

### Registry Names vs Display Names
- **Registry**: Use exact names from port registry (e.g., `zmart_api`, `api_keys_manager_service`)
- **Display**: Use friendly names for documentation (e.g., `zmart-api`, `api-keys-manager-service`)

### Directory Mapping
- Service directories use underscores: `zmart_api`, `api_keys_manager`
- Service names in registry match directory names

## Verification Commands

### Check Service Integration
```bash
# Verify service is in orchestration
./orchestrationstart.sh status | grep "service-name"

# Test health check
./orchestrationstart.sh health "service-name"

# Test startup
./orchestrationstart.sh start "service-name"
```

### Check System Integration
```bash
# Verify in port registry
sqlite3 zmart-api/port_registry.db "SELECT * FROM port_assignments WHERE service_name = 'service-name';"

# Verify in Master Orchestration
grep -n "service-name" .cursor/rules/MasterOrchestrationAgent.mdc
```

## Common Issues & Solutions

### Issue: Service not found in orchestration
**Solution**: Check service name mapping in `get_service_dir()` and `get_service_command()` functions

### Issue: Service starts but health check fails
**Solution**: Verify service has `/health` endpoint and is responding correctly

### Issue: Service not in startup order
**Solution**: Check SERVICE_STARTUP_ORDER array and ensure dependencies are listed first

### Issue: Port conflicts during startup
**Solution**: Verify port is not already assigned in port registry

## Integration Checklist

- [ ] Service registered in port registry
- [ ] Service added to orchestrationstart.sh
- [ ] Service tested via orchestration
- [ ] Health check passes
- [ ] Service appears in status
- [ ] Master Orchestration Agent updated
- [ ] Service starts with system restart

## Example Integration

For a new service `my-new-service` on port 8001:

1. **Register in port registry**
2. **Add to orchestrationstart.sh**:
   - `"my_new_service"` to SERVICE_STARTUP_ORDER
   - `"my_new_service") echo "my_new_service" ;;` to get_service_dir()
   - `"my_new_service") echo "python3 my_new_service_server.py --port 8001" ;;` to get_service_command()
3. **Test integration**: `./orchestrationstart.sh start my_new_service`
4. **Update Master Orchestration Agent**
5. **Verify system restart**: `./start_zmartbot_official.sh`

## Critical Notes

- **ALWAYS** integrate new services into orchestration
- **ALWAYS** test via orchestration before considering integration complete
- **ALWAYS** update Master Orchestration Agent documentation
- **NEVER** skip the orchestration integration step
- **VERIFY** service starts automatically with system restart

description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---


## üìÑ Additional Content from OrchestrationStart.mdc
@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---


## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-26T09:03:52.868804

## üìÑ Additional Content from OrchestrationStart.mdc
@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---


## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-27T10:39:58.319545

## üìÑ Additional Content from OrchestrationStart.mdc
@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---


## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-29T07:28:17.493446

## üìÑ Additional Content from OrchestrationStart.mdc
@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---


## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-29T11:57:30.884789

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-29T17:58:21.701808

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-29T22:55:51.651730

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-30T11:06:01.148506

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-30T07:23:02.306448

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-30T11:32:15.307610

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-30T15:34:11.036454

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 32 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-31)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 5 services (Discovery, master orchestration, MDC dashboard, certification, achievements)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-31T03:55:38.436628

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 33 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-32)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**
32. **`enhanced-mdc-monitor`** (Port NULL) - Enhanced MDC Monitor ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250830-ENHANCED**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 6 services (Discovery, master orchestration, MDC dashboard, certification, achievements, enhanced MDC monitor)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-31T09:30:55.368143

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 33 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-32)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**
32. **`enhanced-mdc-monitor`** (Port NULL) - Enhanced MDC Monitor ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250830-ENHANCED**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 6 services (Discovery, master orchestration, MDC dashboard, certification, achievements, enhanced MDC monitor)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-31T14:25:51.269634

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 33 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-32)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**
32. **`enhanced-mdc-monitor`** (Port NULL) - Enhanced MDC Monitor ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250830-ENHANCED**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 6 services (Discovery, master orchestration, MDC dashboard, certification, achievements, enhanced MDC monitor)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-08-31T20:10:54.501812

## üìÑ Additional Content from OrchestrationStart.mdc

## Description
Core orchestration service component of the ZmartBot ecosystem providing essential functionality.

@step: orchestration_flow

# OrchestrationStart - Project Startup Orchestration Process

## Overview
The OrchestrationStart process is responsible for coordinating the startup of the entire ZmartBot project, ensuring proper port management, service coordination, and database synchronization between startup and shutdown cycles.

## What OrchestrationStart Does

### 1. **Core Service Verification** (Ports 3400 & 8000)
- **Frontend Dashboard**: Ensures service is running on port 3400
  - Professional Dashboard Server
  - React/Vite development server
  - Web interface accessibility
  - Health check verification

- **Backend API**: Ensures service is running on port 8000
  - FastAPI Backend Server
  - RESTful API endpoints
  - Database connections
  - External API integrations

### 2. **Port Manager Database Check**
- **Database Location**: `src/data/port_registry.db`
- **Purpose**: Verify all currently assigned ports
- **Checks**:
  - Existing port assignments
  - Service-to-port mappings
  - Port availability status
  - Orphaned port entries

### 3. **New Port Assignment Detection**
- **Trigger**: Previous STOP_ZMARTBOT execution
- **Process**:
  - Scan for new port assignments made by Port Manager
  - Identify services that received new ports during conflicts
  - Verify port assignment persistence
  - Check for any unregistered services

### 4. **Database Synchronization**
- **Old Ports**: Update existing port assignments
- **New Ports**: Register newly assigned ports
- **Cleanup**: Remove orphaned or invalid entries
- **Validation**: Ensure all services have valid port mappings

## Complete Service List (Updated 2025-08-28)

### **All Services Managed by OrchestrationStart**

**Total Services**: 33 services with proper startup order and dependency management

#### **Critical Infrastructure Services** (Startup Priority 1-5)
1. **`system-protection-service`** (Port 8999) - CRITICAL System Protection ‚úÖ
2. **`optimization-claude-service`** (Port 8080) - HIGH Priority Optimization ‚úÖ
3. **`snapshot-service`** (Port 8085) - CRITICAL Disaster Recovery ‚úÖ
4. **`passport-service`** (Port 8620) - Service Registration & Identity Management ‚úÖ
5. **`doctor-service`** (Port 8700) - AI-Powered System Diagnostics ‚úÖ

#### **Core System Services** (Startup Priority 6-10)
6. **`servicelog-service`** (Port 8750) - Intelligent Log Analysis & Advice System ‚úÖ
7. **`zmart_api`** (Port 8000) - Core API ‚úÖ
8. **`port-manager-service`** (Port 8050) - Port Management ‚úÖ
9. **`api-keys-manager-service`** (Port 8006) - API Keys Management ‚úÖ
10. **`mdc-orchestration-agent`** (Port 8615) - MDC Orchestration ‚úÖ

#### **Frontend Services** (Startup Priority 11-12)
11. **`zmart_dashboard`** (Port 3400) - Frontend Dashboard ‚úÖ
12. **`service-dashboard`** (Port 3000) - Service Dashboard ‚úÖ

#### **Analytics & Data Services** (Startup Priority 13-17)
13. **`zmart_analytics`** (Port 8007) - Analytics ‚úÖ
14. **`zmart_backtesting`** (Port 8013) - Backtesting ‚úÖ
15. **`zmart_data_warehouse`** (Port 8015) - Data Warehouse ‚úÖ
16. **`zmart_machine_learning`** (Port 8014) - Machine Learning ‚úÖ
17. **`zmart_risk_management`** (Port 8010) - Risk Management ‚úÖ

#### **Communication & Notification Services** (Startup Priority 18-20)
18. **`zmart_notification`** (Port 8008) - Notifications ‚úÖ
19. **`zmart_websocket`** (Port 8009) - WebSocket ‚úÖ
20. **`zmart_alert_system`** (Port 8012) - Alert System ‚úÖ

#### **Trading & Analysis Services** (Startup Priority 21-23)
21. **`zmart_technical_analysis`** (Port 8011) - Technical Analysis ‚úÖ
22. **`my-symbols-extended-service`** (Port 8005) - Symbols Extended ‚úÖ
23. **`mysymbols`** (Port 8201) - MySymbols Internal API ‚úÖ

#### **Worker Services** (Startup Priority 24-26)
24. **`test-service`** (Port 8301) - Test Service Worker ‚úÖ
25. **`kucoin`** (Port 8302) - KuCoin Worker ‚úÖ
26. **`binance`** (Port 8303) - Binance Worker ‚úÖ

#### **Orchestration & Discovery Services** (Startup Priority 27-32)
27. **`service-discovery`** (Port 8550) - Service Discovery & Port Assignment ‚úÖ
28. **`master-orchestration-agent`** (Port 8002) - Master Orchestration ‚úÖ
29. **`mdc-dashboard`** (Port 8090) - MDC Dashboard System ‚úÖ **PASSPORT: ZMBT-BACKEND-20250827-4A6247**
30. **`certification`** (Port 8901) - Certification Service ‚úÖ **PASSPORT: ZMBT-BACKEND-20250828-158364**
31. **`achievements`** (Port NULL) - Achievements Service ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250828-AB513A**
32. **`enhanced-mdc-monitor`** (Port NULL) - Enhanced MDC Monitor ‚úÖ **PASSPORT: ZMBT-SYSTEM-20250830-ENHANCED**

### **Service Categories Summary**
- **Critical Infrastructure**: 5 services (System protection, optimization, snapshot, passport, doctor)
- **Core System**: 5 services (API, port management, keys, orchestration, logging)
- **Frontend**: 2 services (Dashboard, service dashboard)
- **Analytics & Data**: 5 services (Analytics, backtesting, warehouse, ML, risk management)
- **Communication**: 3 services (Notifications, WebSocket, alerts)
- **Trading & Analysis**: 3 services (Technical analysis, symbols, MySymbols)
- **Workers**: 3 services (Test, KuCoin, Binance)
- **Orchestration**: 6 services (Discovery, master orchestration, MDC dashboard, certification, achievements, enhanced MDC monitor)

### **Passport Services Integration**
**All 33 passport services are now included in OrchestrationStart:**
- ‚úÖ **Previously Missing**: 28 services added
- ‚úÖ **Previously Included**: 17 services (with naming corrections)
- ‚úÖ **Newly Added**: 3 services (MDC Dashboard, Certification, Achievements)
- ‚úÖ **Total Coverage**: 100% of passport services managed

### **Dependency Management**
- **Startup Order**: Optimized for dependency resolution
- **Port Conflicts**: Automatically resolved by Port Manager
- **Health Checks**: Each service verified before next service starts
- **Error Recovery**: Automatic retry and fallback mechanisms

## Profile-Driven OrchestrationStart Workflow

### Phase 1: Profile Detection & Loading
@step: load_active_profile
```python
# Load active service profile
def load_active_profile():
    """Load the currently active service profile"""
    profile_path = "/profiles/current"
    
    if os.path.exists(profile_path):
        with open(profile_path, 'r') as f:
            active_profile = json.load(f)
        logger.info(f"Loaded active profile: {active_profile['name']}")
        return active_profile
    else:
        # Fallback to default ACTIVE set
        default_profile = {
            "name": "default",
            "services": ["backend_api", "dashboard_server", "orchestration_agent"],
            "description": "Default core services"
        }
        logger.info("No active profile found, using default ACTIVE set")
        return default_profile
```

### Phase 2: Load Current Profile
@step: load_current_profile
```python
def load_current_profile():
    """Load the current active profile from Service Registry"""
    import requests
    
    try:
        # Try to get current profile
        response = requests.get("http://127.0.0.1:8610/profiles/current", timeout=3)
        data = response.json()
        
        if data.get("services"):
            # Current profile exists, get full service details
            active_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return active_response.json()
        else:
            # No current profile, fallback to default (ACTIVE services)
            fallback_response = requests.get("http://127.0.0.1:8610/profiles/default", timeout=3)
            return fallback_response.json()
            
    except Exception as e:
        logger.error(f"Failed to load profile: {e}")
        # Fallback to default services
        return [
            {"service_name": "backend-api", "port": 8000, "start_cmd": "python3 run_dev.py"},
            {"service_name": "frontend", "port": 3400, "start_cmd": "python3 professional_dashboard_server.py --port 3400"}
        ]
```

### Phase 3: Start Services in Order
@step: start_services_in_order
```python
def start_services_in_order(services):
    """Start services in dependency order"""
    import subprocess
    import time
    import requests
    
    for service in services:
        service_name = service["service_name"]
        start_cmd = service.get("start_cmd")
        port = service.get("port")
        health_url = service.get("health_url")
        
        if not start_cmd:
            logger.warning(f"[SKIP] {service_name}: no start_cmd")
            continue
        
        logger.info(f"[START] {service_name} -> {start_cmd}")
        
        try:
            # Start service
            subprocess.Popen(start_cmd.split(), stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)
            
            # Wait for service to start
            time.sleep(0.4)
            
            # Verify service is running
            if health_url:
                try:
                    response = requests.get(health_url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"‚úÖ {service_name} started successfully on port {port}")
                    else:
                        logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {response.status_code}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è {service_name} started but health check failed: {e}")
            else:
                logger.info(f"‚úÖ {service_name} started on port {port}")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to start {service_name}: {e}")
            # Continue with other services
```

### Phase 4: Finalize
@step: finalize
```python
def finalize_orchestration(services):
    """Print service status table and hand off to MasterOrchestrationAgent"""
    import psutil
    
    print("\nüéØ ORCHESTRATION STARTUP COMPLETE")
    print("=" * 50)
    print("Service ‚áÑ Port ‚áÑ PID ‚áÑ Status")
    print("-" * 50)
    
    for service in services:
        service_name = service["service_name"]
        port = service.get("port", "N/A")
        
        # Find PID by port
        pid = "N/A"
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    pid = conn.pid
                    break
        except:
            pass
        
        # Check status
        status = "RUNNING" if pid != "N/A" else "UNKNOWN"
        
        print(f"{service_name:<15} {port:<6} {pid:<6} {status}")
    
    print("=" * 50)
    print("Handing off to MasterOrchestrationAgent...")
    
    # Hand off to MasterOrchestrationAgent
    return services

@step: state_snapshot_management
```python
def manage_state_snapshot():
    """Handle state snapshot for smooth startup experience"""
    if state_screenshot_exists():
        log_info("üì∏ Found state screenshot - serving cached data")
        serve_cached_data()
        
        # Wait for all services to be ready
        wait_for_services_ready()
        
        # Transition to live data
        log_info("üì∏‚Üíüî¥ TRANSITION: Cached data ‚Üí Live data")
        log_info("üîÑ System fully ready - clearing cached data for live operation")
        clear_cached_data()
        log_success("‚úÖ Now serving live data from all services")
    else:
        log_info("No state screenshot found - starting with fresh data")
```

@step: service_discovery_and_assignment
```python
def discover_and_assign_new_services():
    """Discover new services and assign ports automatically"""
    # Detect new services
    new_services = detect_new_services()
    
    if new_services:
        log_info(f"üîç Found {len(new_services)} new services to integrate")
        
        # Assign ports to new services
        for service in new_services:
            port = assign_port_to_new_service(service)
            log_info(f"‚úÖ Assigned port {port} to {service.name}")
        
        # Notify Master Orchestration Agent
        notify_master_orchestration_agent(new_services)
        
        log_success(f"üéØ Integrated {len(new_services)} new services into orchestration")
    else:
        log_info("No new services detected")
```
```

### Phase 3: BackendDoctorAgent Activation
@step: start_BackendDoctorAgent
```bash
# Activate BackendDoctorAgent in monitoring mode
@agent: BackendDoctorAgent

# Begin logging to doctor_monitor.log
python3 doctor.py --monitor 120 &
```

### Phase 4: MDC File Watcher Activation
@step: start_MDCFileWatcher
```bash
# Activate MDC file watcher for automatic CLAUDE.md updates
@agent: ClaudeMDCUpdateAgent

# Start file watcher in background
cd /Users/dansidanutz/Desktop/ZmartBot/zmart-api
source venv/bin/activate
nohup python3 watch_mdc_changes_simple.py > mdc_watcher.log 2>&1 &
```

**BackendDoctorAgent Integration:**
- **Activation**: `@agent: BackendDoctorAgent` for comprehensive health monitoring
- **Monitoring Mode**: Continuous health monitoring with 120-second intervals
- **Logging**: All health data logged to `doctor_monitor.log`
- **Auto-Recovery**: Automatic problem detection and resolution
- **Health Reporting**: Real-time system health status and recommendations

### Phase 2: Port Manager Database Analysis
```python
# Access port registry database
from src.utils.port_registry import port_registry

# Get all current assignments
current_assignments = port_registry.get_all_services()

# Check for new assignments
new_assignments = port_registry.get_new_assignments()
```

### Phase 3: Port Assignment Reconciliation
```python
# Update database with new assignments
for service in new_assignments:
    port_registry.update_service_port(
        service_name=service.name,
        port=service.port,
        pid=service.pid
    )

# Clean up orphaned entries
port_registry.cleanup_orphaned_services()
```

### Phase 4: Database Synchronization
```python
# Ensure all services are properly registered
port_registry.sync_all_services()

# Update orchestration configuration
update_orchestration_config()
```

## Port Management Integration

### Port Registry Database Schema
```sql
-- Service assignments table
CREATE TABLE port_assignments (
    id INTEGER PRIMARY KEY,
    service_name TEXT NOT NULL,
    port INTEGER NOT NULL,
    pid INTEGER,
    status TEXT DEFAULT 'RUNNING',
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Service Types Managed
- **Backend API**: Port 8000 (Fixed)
- **Dashboard Server**: Port 3400 (Fixed)
- **Orchestration Agent**: Dynamic assignment
- **KingFisher Service**: Dynamic assignment
- **Additional Services**: Dynamic assignment

## STOP_ZMARTBOT Integration

### Before STOP
- Port Manager saves current assignments
- New port assignments are recorded
- Service status is updated

### After START
- OrchestrationStart reads saved assignments
- New ports are applied to services
- Database is synchronized
- All services are verified

## Error Handling

### Port Conflicts
- **Detection**: Port already in use
- **Resolution**: Assign new port automatically
- **Recording**: Save new assignment to database
- **Notification**: Log port change

### Service Failures
- **Detection**: Service not responding
- **Retry**: Attempt restart with same port
- **Fallback**: Assign new port if needed
- **Monitoring**: Track service health

### Database Issues
- **Backup**: Create backup before changes
- **Validation**: Verify data integrity
- **Recovery**: Restore from backup if needed
- **Logging**: Record all database operations

## Configuration Files

### Port Registry Configuration
```json
{
  "database_path": "src/data/port_registry.db",
  "backup_enabled": true,
  "auto_cleanup": true,
  "conflict_resolution": "auto_assign"
}
```

### Orchestration Configuration
```json
{
  "core_services": {
    "backend_api": {"port": 8000, "fixed": true},
    "dashboard_server": {"port": 3400, "fixed": true}
  },
  "dynamic_services": {
    "orchestration_agent": {"auto_assign": true},
    "kingfisher_service": {"auto_assign": true}
  }
}
```

## Monitoring and Logging

### Health Checks
- Service responsiveness
- Port availability
- Database connectivity
- Process status

### Logging
- Port assignment changes
- Service startup/shutdown
- Database operations
- Error conditions

### Metrics
- Port utilization
- Service uptime
- Conflict resolution frequency
- Database performance

## Integration Points

### With START_ZMARTBOT.sh
- Called after core services start
- Verifies service health
- Updates port assignments
- Synchronizes database

### With STOP_ZMARTBOT.sh
- Saves current port state
- Records new assignments
- Prepares for next startup
- Cleans up resources

### With Port Manager
- Reads port assignments
- Updates service mappings
- Manages conflicts
- Maintains database

### With BackendDoctorAgent
- Activates comprehensive health monitoring
- Provides real-time system health analysis
- Enables automatic problem resolution
- Maintains health monitoring logs
- Integrates with service startup verification

## Success Criteria

### Service Verification
- ‚úÖ Frontend Dashboard responding on port 3400
- ‚úÖ Backend API responding on port 8000
- ‚úÖ All dynamic services have valid ports
- ‚úÖ No port conflicts detected

### Database Synchronization
- ‚úÖ All services registered in database
- ‚úÖ Port assignments are current
- ‚úÖ No orphaned entries
- ‚úÖ Backup created successfully

### Orchestration Status
- ‚úÖ All services coordinated
- ‚úÖ Port Manager database updated
- ‚úÖ Configuration files synchronized
- ‚úÖ BackendDoctorAgent monitoring active
- ‚úÖ System ready for operations

This orchestration process ensures that ZmartBot starts consistently with proper port management and service coordination across all startup/shutdown cycles.
description:
globs:
alwaysApply: true

## Requirements
- ‚úÖ **Unique port assignment**
- ‚úÖ **Database connectivity**
- ‚úÖ **Valid service passport**
- ‚úÖ **Complete MDC documentation**
- ‚úÖ **Health endpoint implementation**


---

## Triggers
- **API endpoint requests**
- **File system changes**
- **Database events**


---
**Merge Summary**: Combined 2 files into unified MDC configuration
**Generated**: 2025-09-01T00:11:21.375593