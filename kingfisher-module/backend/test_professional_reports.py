#!/usr/bin/env python3
"""
Test Professional Report Generation System
Comprehensive testing of enhanced reports, automated reports, and master summaries
"""

import asyncio
import sys
import os
import logging
from datetime import datetime
import json

# Add src to path for imports
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

from src.services.enhanced_report_generator import EnhancedReportGenerator
from src.services.automated_report_system import automated_report_system
from src.services.master_summary_agent import MasterSummaryAgent

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def test_enhanced_report_generator():
    """Test the enhanced report generator"""
    try:
        logger.info("üß™ Testing Enhanced Report Generator...")
        
        # Initialize the report generator
        generator = EnhancedReportGenerator()
        
        # Test data for different report types
        test_data = {
            "symbol": "BTCUSDT",
            "current_price": 45000.0,
            "sentiment": "bullish",
            "confidence": 85.5,
            "risk_level": "medium",
            "analysis_type": "liquidation_map",
            "liquidation_zones": [
                {"price_level": 44000, "volume": 1000000, "intensity": 75},
                {"price_level": 43000, "volume": 800000, "intensity": 60},
                {"price_level": 42000, "volume": 600000, "intensity": 45}
            ],
            "support_levels": [44000, 43000, 42000],
            "resistance_levels": [46000, 47000, 48000],
            "volatility": 25.5,
            "timeframe": "24h"
        }
        
        # Test liquidation map report
        logger.info("üìä Testing liquidation map report generation...")
        liquidation_report = await generator.generate_enhanced_report(test_data, "liquidation_map")
        
        print(f"\n‚úÖ Liquidation Map Report Generated:")
        print(f"  ‚Ä¢ Report ID: {liquidation_report.report_id}")
        print(f"  ‚Ä¢ Symbol: {liquidation_report.symbol}")
        print(f"  ‚Ä¢ Confidence: {liquidation_report.confidence_score:.1f}%")
        print(f"  ‚Ä¢ Risk Level: {liquidation_report.risk_level}")
        print(f"  ‚Ä¢ Sections: {len(liquidation_report.sections)}")
        print(f"  ‚Ä¢ Report Length: {len(liquidation_report.formatted_report)} characters")
        
        # Test liquidation heatmap report
        logger.info("üî• Testing liquidation heatmap report generation...")
        heatmap_data = {
            **test_data,
            "analysis_type": "liquidation_heatmap",
            "thermal_zones": [
                {"price_level": 45000, "intensity": 90},
                {"price_level": 44000, "intensity": 75},
                {"price_level": 43000, "intensity": 60}
            ],
            "intensity_scores": {
                "high": 90,
                "medium": 75,
                "low": 60
            }
        }
        
        heatmap_report = await generator.generate_enhanced_report(heatmap_data, "liquidation_heatmap")
        
        print(f"\n‚úÖ Liquidation Heatmap Report Generated:")
        print(f"  ‚Ä¢ Report ID: {heatmap_report.report_id}")
        print(f"  ‚Ä¢ Symbol: {heatmap_report.symbol}")
        print(f"  ‚Ä¢ Confidence: {heatmap_report.confidence_score:.1f}%")
        print(f"  ‚Ä¢ Risk Level: {heatmap_report.risk_level}")
        print(f"  ‚Ä¢ Sections: {len(heatmap_report.sections)}")
        
        # Test multi-symbol report
        logger.info("üìà Testing multi-symbol report generation...")
        multi_symbol_data = {
            "symbols": ["BTCUSDT", "ETHUSDT", "SOLUSDT"],
            "analysis_type": "multi_symbol",
            "market_sentiment": "bullish",
            "market_conditions": "Normal",
            "BTCUSDT_sentiment": "bullish",
            "BTCUSDT_confidence": 85.5,
            "BTCUSDT_risk": "medium",
            "BTCUSDT_recommendation": "Strong Buy",
            "ETHUSDT_sentiment": "bullish",
            "ETHUSDT_confidence": 78.2,
            "ETHUSDT_risk": "medium",
            "ETHUSDT_recommendation": "Buy",
            "SOLUSDT_sentiment": "neutral",
            "SOLUSDT_confidence": 65.0,
            "SOLUSDT_risk": "high",
            "SOLUSDT_recommendation": "Hold"
        }
        
        multi_symbol_report = await generator.generate_enhanced_report(multi_symbol_data, "multi_symbol")
        
        print(f"\n‚úÖ Multi-Symbol Report Generated:")
        print(f"  ‚Ä¢ Report ID: {multi_symbol_report.report_id}")
        print(f"  ‚Ä¢ Symbols: {multi_symbol_report.symbol}")
        print(f"  ‚Ä¢ Confidence: {multi_symbol_report.confidence_score:.1f}%")
        print(f"  ‚Ä¢ Risk Level: {multi_symbol_report.risk_level}")
        print(f"  ‚Ä¢ Sections: {len(multi_symbol_report.sections)}")
        
        # Test general report
        logger.info("üìã Testing general report generation...")
        general_report = await generator.generate_enhanced_report(test_data, "general")
        
        print(f"\n‚úÖ General Report Generated:")
        print(f"  ‚Ä¢ Report ID: {general_report.report_id}")
        print(f"  ‚Ä¢ Symbol: {general_report.symbol}")
        print(f"  ‚Ä¢ Confidence: {general_report.confidence_score:.1f}%")
        print(f"  ‚Ä¢ Risk Level: {general_report.risk_level}")
        print(f"  ‚Ä¢ Sections: {len(general_report.sections)}")
        
        print(f"\nüìÑ Sample Report Content (first 500 chars):")
        print(f"  {general_report.formatted_report[:500]}...")
        
        logger.info("‚úÖ Enhanced Report Generator tests completed successfully")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Enhanced Report Generator test failed: {str(e)}")
        print(f"\n‚ùå Test failed: {str(e)}")
        return False

async def test_automated_report_system():
    """Test the automated report system"""
    try:
        logger.info("ü§ñ Testing Automated Report System...")
        
        # Start the automated system
        logger.info("üöÄ Starting automated report system...")
        await automated_report_system.start_automation()
        
        # Test data
        test_data = {
            "symbol": "ETHUSDT",
            "current_price": 3200.0,
            "sentiment": "bullish",
            "confidence": 82.5,
            "risk_level": "medium",
            "analysis_type": "liquidation_map",
            "liquidation_zones": [
                {"price_level": 3150, "volume": 500000, "intensity": 70},
                {"price_level": 3100, "volume": 400000, "intensity": 55}
            ],
            "support_levels": [3150, 3100],
            "resistance_levels": [3250, 3300],
            "volatility": 20.0,
            "timeframe": "24h"
        }
        
        # Test adding a job to the queue
        logger.info("üìù Testing job queue addition...")
        job_id = await automated_report_system.add_report_job(
            symbol="ETHUSDT",
            analysis_type="liquidation_map",
            analysis_data=test_data,
            priority=1
        )
        
        print(f"\n‚úÖ Job added to queue:")
        print(f"  ‚Ä¢ Job ID: {job_id}")
        print(f"  ‚Ä¢ Symbol: ETHUSDT")
        print(f"  ‚Ä¢ Analysis Type: liquidation_map")
        print(f"  ‚Ä¢ Priority: 1")
        
        # Get system status
        logger.info("üìä Getting system status...")
        status = await automated_report_system.get_system_status()
        
        print(f"\nüìä System Status:")
        print(f"  ‚Ä¢ Running: {status['is_running']}")
        print(f"  ‚Ä¢ Queue Size: {status['queue_size']}")
        print(f"  ‚Ä¢ Completed Count: {status['completed_count']}")
        print(f"  ‚Ä¢ Pending Jobs: {len(status['pending_jobs'])}")
        
        # Test immediate report generation
        logger.info("‚ö° Testing immediate report generation...")
        immediate_report = await automated_report_system.trigger_immediate_report(
            symbol="SOLUSDT",
            analysis_type="general",
            analysis_data={
                "symbol": "SOLUSDT",
                "current_price": 150.0,
                "sentiment": "neutral",
                "confidence": 70.0,
                "risk_level": "medium",
                "volatility": 15.0,
                "timeframe": "24h"
            }
        )
        
        print(f"\n‚úÖ Immediate Report Generated:")
        print(f"  ‚Ä¢ Report ID: {immediate_report.report_id}")
        print(f"  ‚Ä¢ Symbol: {immediate_report.symbol}")
        print(f"  ‚Ä¢ Confidence: {immediate_report.confidence_score:.1f}%")
        print(f"  ‚Ä¢ Risk Level: {immediate_report.risk_level}")
        
        # Wait a bit for queue processing
        logger.info("‚è≥ Waiting for queue processing...")
        await asyncio.sleep(3)
        
        # Get job status
        if job_id:
            logger.info(f"üìã Getting job status for {job_id}...")
            job_status = await automated_report_system.get_report_status(job_id)
            
            if job_status:
                print(f"\nüìã Job Status:")
                print(f"  ‚Ä¢ Job ID: {job_status.job_id}")
                print(f"  ‚Ä¢ Status: {job_status.status}")
                print(f"  ‚Ä¢ Symbol: {job_status.symbol}")
                print(f"  ‚Ä¢ Created: {job_status.created_at}")
                if job_status.completed_at:
                    print(f"  ‚Ä¢ Completed: {job_status.completed_at}")
                if job_status.report:
                    print(f"  ‚Ä¢ Report ID: {job_status.report.report_id}")
                    print(f"  ‚Ä¢ Confidence: {job_status.report.confidence_score:.1f}%")
        
        # Get statistics
        logger.info("üìà Getting report statistics...")
        stats = await automated_report_system.get_report_statistics()
        
        print(f"\nüìà Report Statistics:")
        print(f"  ‚Ä¢ Total Reports: {stats['total_reports']}")
        print(f"  ‚Ä¢ Success Rate: {stats['success_rate']:.1f}%")
        print(f"  ‚Ä¢ Average Processing Time: {stats['average_processing_time']:.2f}s")
        print(f"  ‚Ä¢ Reports by Type: {stats['reports_by_type']}")
        print(f"  ‚Ä¢ Reports by Symbol: {stats['reports_by_symbol']}")
        
        # Stop the automated system
        logger.info("üõë Stopping automated report system...")
        await automated_report_system.stop_automation()
        
        logger.info("‚úÖ Automated Report System tests completed successfully")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Automated Report System test failed: {str(e)}")
        print(f"\n‚ùå Test failed: {str(e)}")
        return False

async def test_master_summary_integration():
    """Test the integration between automated reports and master summary"""
    try:
        logger.info("üéØ Testing Master Summary Integration...")
        
        # Initialize the master summary agent
        master_agent = MasterSummaryAgent()
        
        # Generate a master summary
        logger.info("üìä Generating master summary...")
        master_summary = await master_agent.generate_master_summary(hours_back=24)
        
        print(f"\nüéØ Master Summary Generated:")
        print(f"  ‚Ä¢ Overall Sentiment: {master_summary.overall_sentiment}")
        print(f"  ‚Ä¢ Market Confidence: {master_summary.market_confidence:.1f}%")
        print(f"  ‚Ä¢ Market Trend: {master_summary.market_trend}")
        print(f"  ‚Ä¢ Top Performers: {len(master_summary.top_performers)}")
        print(f"  ‚Ä¢ Risk Alerts: {len(master_summary.risk_alert_symbols)}")
        print(f"  ‚Ä¢ Trading Opportunities: {len(master_summary.trading_opportunities)}")
        print(f"  ‚Ä¢ Sector Analysis: {len(master_summary.sector_analysis)}")
        print(f"  ‚Ä¢ Risk Warnings: {len(master_summary.risk_warnings)}")
        
        print(f"\nüìù Executive Summary:")
        print(f"  {master_summary.executive_summary}")
        
        if master_summary.professional_summary:
            print(f"\nüìÑ Professional Summary Preview (first 300 chars):")
            print(f"  {master_summary.professional_summary[:300]}...")
        
        logger.info("‚úÖ Master Summary Integration tests completed successfully")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Master Summary Integration test failed: {str(e)}")
        print(f"\n‚ùå Test failed: {str(e)}")
        return False

async def test_api_endpoints():
    """Test the API endpoints for professional reports"""
    try:
        logger.info("üåê Testing API Endpoints...")
        
        import httpx
        
        base_url = "http://localhost:8100"
        
        # Test automated reports health endpoint
        print("\nüè• Testing automated reports health endpoint...")
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{base_url}/api/v1/automated-reports/health")
            if response.status_code == 200:
                health_data = response.json()
                print(f"‚úÖ Health check passed: {health_data.get('status', 'unknown')}")
                print(f"   System running: {health_data.get('system_running', False)}")
                print(f"   Queue size: {health_data.get('queue_size', 0)}")
            else:
                print(f"‚ùå Health check failed: {response.status_code}")
        
        # Test system status endpoint
        print("\nüìä Testing system status endpoint...")
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{base_url}/api/v1/automated-reports/system-status")
            if response.status_code == 200:
                status_data = response.json()
                print(f"‚úÖ System status retrieved:")
                print(f"   Running: {status_data.get('is_running', False)}")
                print(f"   Queue size: {status_data.get('queue_size', 0)}")
                print(f"   Completed count: {status_data.get('completed_count', 0)}")
            else:
                print(f"‚ùå System status failed: {response.status_code}")
        
        # Test statistics endpoint
        print("\nüìà Testing statistics endpoint...")
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{base_url}/api/v1/automated-reports/statistics")
            if response.status_code == 200:
                stats_data = response.json()
                print(f"‚úÖ Statistics retrieved:")
                print(f"   Status: {stats_data.get('status', 'unknown')}")
                if 'statistics' in stats_data:
                    stats = stats_data['statistics']
                    print(f"   Total reports: {stats.get('total_reports', 0)}")
                    print(f"   Success rate: {stats.get('success_rate', 0):.1f}%")
            else:
                print(f"‚ùå Statistics failed: {response.status_code}")
        
        # Test immediate report generation
        print("\n‚ö° Testing immediate report generation...")
        test_data = {
            "symbol": "ADAUSDT",
            "current_price": 0.45,
            "sentiment": "neutral",
            "confidence": 75.0,
            "risk_level": "medium",
            "analysis_type": "general",
            "volatility": 18.0,
            "timeframe": "24h"
        }
        
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{base_url}/api/v1/automated-reports/generate-immediate",
                json={
                    "symbol": "ADAUSDT",
                    "analysis_type": "general",
                    "analysis_data": test_data
                }
            )
            if response.status_code == 200:
                report_data = response.json()
                print(f"‚úÖ Immediate report generated:")
                print(f"   Status: {report_data.get('status', 'unknown')}")
                print(f"   Symbol: {report_data.get('symbol', 'unknown')}")
                print(f"   Report ID: {report_data.get('report_id', 'unknown')}")
                print(f"   Confidence: {report_data.get('confidence_score', 0):.1f}%")
            else:
                print(f"‚ùå Immediate report generation failed: {response.status_code}")
        
        print("\n" + "="*60)
        print("‚úÖ API ENDPOINTS TEST COMPLETED")
        print("="*60)
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå API endpoints test failed: {str(e)}")
        print(f"\n‚ùå API test failed: {str(e)}")
        return False

async def main():
    """Main test function"""
    print("üéØ Professional Report Generation System Test Suite")
    print("="*60)
    
    # Test enhanced report generator
    enhanced_success = await test_enhanced_report_generator()
    
    # Test automated report system
    automated_success = await test_automated_report_system()
    
    # Test master summary integration
    master_success = await test_master_summary_integration()
    
    # Test API endpoints (if server is running)
    api_success = await test_api_endpoints()
    
    print(f"\nüìä Test Results:")
    print(f"  ‚Ä¢ Enhanced Report Generator: {'‚úÖ PASSED' if enhanced_success else '‚ùå FAILED'}")
    print(f"  ‚Ä¢ Automated Report System: {'‚úÖ PASSED' if automated_success else '‚ùå FAILED'}")
    print(f"  ‚Ä¢ Master Summary Integration: {'‚úÖ PASSED' if master_success else '‚ùå FAILED'}")
    print(f"  ‚Ä¢ API Endpoints: {'‚úÖ PASSED' if api_success else '‚ùå FAILED'}")
    
    if enhanced_success and automated_success and master_success and api_success:
        print("\nüéâ All tests passed! Professional Report Generation System is working correctly.")
        print("\nüöÄ The system is now ready to:")
        print("  ‚Ä¢ Generate enhanced professional reports")
        print("  ‚Ä¢ Automate report generation workflows")
        print("  ‚Ä¢ Compose master summaries from all analyses")
        print("  ‚Ä¢ Provide commercial-grade trading intelligence")
    else:
        print("\n‚ö†Ô∏è Some tests failed. Please check the logs for details.")

if __name__ == "__main__":
    asyncio.run(main()) 